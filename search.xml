<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C# Study 2]]></title>
    <url>%2FC-study-2.html</url>
    <content type="text"><![CDATA[ASP.Net Response.Redirect or Server.Transfer: Open New Tab from Code Behind Thus with the help of JavaScript we can set the target property of form to _blank whenever we want to open the page in a new window. Refer belowI have an ASP.Net Button12345Aspx&lt;asp:Button ID=&quot;Button1&quot; runat=&quot;server&quot; Text=&quot;Button&quot; onclick=&quot;Button1_Click&quot; OnClientClick = &quot;SetTarget();&quot; /&gt; I am calling the SetTarget() JavaScript function OnClientClick event of the ASP.Net Button Control as described below12345678910JavaScript&lt;script type = "text/javascript"&gt; function SetTarget() &#123; document.forms[0].target = "_blank"; &#125;&lt;/script&gt; As you can see above I am setting the target property of the HTML FORM to _blankSecondly I am calling the Button1_Click method OnClick event Control as described below1234567C#protected void Button1_Click(object sender, EventArgs e)&#123; Response.Redirect(&quot;page2.aspx&quot;);&#125; 1234567VB.NetProtected Sub Button1_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles Button1.Click Response.Redirect("Page2.aspx")End Sub Thus now when you click on the Button, the JavaScript function sets the target property of the form is to _blank Thus when PostBack occurs it first opens the current page in new window and then executes the Response.Redirect method thus helping us achieve our goal.Same way we can use Server.Transfer on the Button Click event123456C#protected void Button1_Click(object sender, EventArgs e)&#123; Server.Transfer(&quot;page2.aspx&quot;);&#125; 123456VB.NetProtected Sub Button1_Click(ByVal sender As Object, ByVal e As System.EventArgs) Handles Button1.Click Server.Transfer("Page2.aspx")End Sub]]></content>
      <categories>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle Database 12C SQL基礎知識]]></title>
    <url>%2FOracle-Database-12C-SQL%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98.html</url>
    <content type="text"><![CDATA[Oracle Database 12C SQL基礎知識 間違いやすい問題〇がある回答:正確回答 〇が無い回答:間違い回答1、正規化とは、データの重複を排除し、データ間の正しいリレーションシップを設定してデータを一元管理できるようにすることです。 ・非正規形非正規形は正規化されていないデータです。 ・第1正規形第1正規化は、非正規形の表に次の作業を行います。・主キーを設定する・繰り返し現れる列のデータをグループ化して、別の表に切り離す・導出項目(他の属性から算出できる項目)を削除する ・第2正規形第2正規化は、第1正規形の表から部分関数従属性であるものを除きます。 ・第3正規形第3正規化は、第2正規形から推移関数従属性を除きます。 2、EMPLOYEES表のDEPARTMENT_IDが1以外の従業員を検索する条件として、正しいものを全て選択して下さい。 WHERE department_id &lt;&gt;= 1WHERE department_id &lt;&gt; 1 〇WHERE department_id = 1WHERE department_id IS NOT 1WHERE department_id ^= 1 〇WHERE department_id != 1 〇 3、次のSQL関数の実行結果として正しいものを1つ選択して下さい。 LENGTH(‘Oracle Web問題集’) LENGTH関数に全角文字は指定できないためエラーとなる13 〇122016 解説LENGTH関数は引数で指定された文字列の長さを返す関数です。“Oracle Web問題集”のように文字列に全角文字やスペースが含まれている場合、全角文字やスペースも1文字としてカウントされます。 4、単一行関数は、文字関数、数値関数、日付関数、変換関数と汎用関数を含みます。 5、次のSQL文のうち、正しいものを全て選択して下さい。 SELECT q’=I’m fine.=’ FROM dual; 〇SELECT Q’[I’m fine.[‘ FROM dual;SELECT Q’aI’m fine.a’ FROM dual; 〇SELECT q’{I’m fine.}’ FROM dual; 〇SELECT q’XI’m fine.x’ FROM dual; 解説代替引用符q演算子の引用符デリミタとして、[],&lt;&gt;,(),{}の記号を使用する場合は、括弧開き/括弧閉じの組合せで使用します。また、引用符デリミタとして英文字を使用する場合、大文字と小文字は区別されるため、どちらか1つに統一しなければなりません。 6、ROUND(9876.54321, -3)の結果は10000である ROUND(8876.54321, -3)の結果は8900である 7、次のSQL関数の実行結果として正しいものを1つ選択して下さい。 SELECT INSTR(‘Oracle Web問題集’, ‘WEB’)FROM dual; 「0」と表示される 〇「-1」と表示される「8」と表示される文字列が見つからないのでエラーとなる 8、SQL*Plusなどで表の構造を表示するためのコマンドとして、正しいものはどれですか(該当するものをすべて選択してください)。 DISTINCTDEFAULTDESCRIBE 〇DESC 〇DECODE 9、EMPLOYEES表の検索結果を以下の形式で表示させるためには、どの問い合わせを実行しますか(該当するものをすべて選択してください)。 社員No 社員名 給与(月給) 1001 山田次郎 500000 1002 佐藤書府 500000 SELECT employee_id “社員No”, employee_name 社員名, salary “給与(月給)” FROM employees; 〇SELECT employee_id 社員No, employee_name 社員名, salary 給与(月給) FROM employees;SELECT employee_id AS “社員No”, employee_name AS “社員名”, salary AS “給与(月給)” FROM employees; 〇SELECT “社員No” AS employee_id, “社員名” AS employee_name, 給与(月給) AS salary FROM employees;SELECT employee_id AS ‘社員No’, employee_name AS ‘社員名’, salary AS ‘給与(月給)’ FROM employees; 10、現在の日時は2010年12月25日14時40分です。TRUNC関数の結果として正しいものはどれですか(該当するものを全て選択して下さい)。ただし、日付の表示書式はRR-MM-DDとします。 TRUNC(SYSDATE, ‘YEAR’)の結果は”10-01-01”である 〇TRUNC(SYSDATE)の結果は”10-01-01”であるTRUNC(SYSDATE, ‘DD’)の結果は”10-12-26”であるTRUNC(SYSDATE, ‘YEAR’)の結果は”11-01-01”であるTRUNC(SYSDATE, ‘DD’)の結果は”10-12-25”である 〇TRUNC(SYSDATE, ‘MONTH’)の結果は”10-12-01”である 〇 11、実行結果に”Oracle”が表示されるのはどの問い合わせですか(該当するものを全て選択して下さい)。 SELECT SUBSTR(‘Oracle Master’, -6) FROM dual;SELECT SUBSTR(‘Oracle Master’, 1, 6) FROM dual; 〇SELECT INSTR(‘Oracle Master’, ‘Master’) FROM dual;SELECT TRIM(REPLACE(‘Oracle Master’, ‘Master’)) FROM dual; 〇SELECT INITCAP(‘oracle’) FROM dual; 〇SELECT CONCAT(‘Oracle ‘, ‘Master’) FROM dual;SELECT TRIM(RPAD(‘Oracle Master’, 7, ‘ ‘)) FROM dual; 〇 12、単一行関数の説明として正しい記述はどれですか(該当するものを全て選択して下さい)。 SELECT句でしか使用できない引数として入力したデータと常に同じデータ型の値を返す引数には常に列名を指定する1行ごとに1つの結果を返す 〇ネストレベルに制限はない 〇 解説単一行関数とは、行ごとに処理を行い、1行につき1件の結果を返す関数です。SELECT句、WHERE句、HAVING句、ORDER BY句などで使用することができます。単一行関数のネストレベルには制限ありません。また、指定した引数と返される結果のデータ型は、必ずしも一致するとは限りません。 13、ORDER BY句によるソートの説明として間違っているものはどれですか。 数値型の昇順では値の小さいものから順に表示されるソート項目にNULL値が混在していた場合のソート結果は不定である 〇日付型の降順では新しい日付から順に表示される文字型のソートでは、大文字と小文字は区別される 14、次の問い合わせを確認してください。 SELECT customer_id, cust_last_name, cust_first_name FROM customers WHERE 1 = 5; この問い合わせの実行結果はどうなりますか。 全てのデータが検索されるdepartment_idが「5」であるデータが検索されるエラーとなるデータは1件も検索されない 〇customer_idが「5」であるデータが検索される 15、列別名を指定したSQL文のうち、エラーが無く実行されるのはどのSQL文ですか(該当するものをすべて選択してください)。 SELECT employee_name AS Employee Name, salary AS Salary FROM employees;SELECT employee_name “Employee Name”, salary AS Salary FROM employees; 〇SELECT employee_name, salary “Salary($)” FROM employees; 〇SELECT employee_name 従業員名, salary AS ‘給与’ FROM employees;SELECT employee_name AS EmployeeName, salary Salary($) FROM employees;SELECT employee_name 従業員名, salary 給与 FROM employees; 〇 解説SQL文の実行結果に表示される列見出しを変更したい場合は、SELECT句に列別名を指定します。列別名は算術式にも指定することができます。列別名は項目名と列別名をスペースで区切るか、明示的にASキーワードで指定します。 列別名はオブジェクトのネーミング規則に従って命名されますが、大文字と小文字を区別したり、ネーミング規則に反する列別名(スペースを使用するなど)を使用する場合は、列別名を二重引用符(“)で囲まなければなりません。 16、SELECT句に指定された算術式に列別名を指定することはできますが、算術式の中で列別名を使用することはできません。 17、算術式を指定できる句として正しいものはどれですか(該当するものを全て選択してください)。 WHERE句 〇GROUP BY句 〇FROM句HAVING句 〇SELECT句 〇ORDER BY句 〇 解説算術式はSELECT句だけではなく、FROM句を除く任意の句で使用できます。 18、SQL関数に関する説明として誤っているものはどれですか。 グループ関数は行グループごとに1つの結果を返す単一行関数は1行ごとに1つの結果を返す単一行関数とグループ関数の2種類があるSQL関数には常に引数が必要である 〇 解説SQL関数とはOracleに予め用意されている関数のことです。多くの関数が引数を必要としますが、SYSDATE関数など引数を必要としない関数もあります。 19、次のSQL文のうち、正常に実行されるものはどれですか(3つ選択して下さい)。ただし、データベースの実行環境は日本語環境とします。 SELECT employee_name “EMPLOYEE NAME” FROM employees ORDER BY EMPLOYEE NAME;SELECT employee_name AS “EMPNAME” FROM employees ORDER BY empname; 〇SELECT employee_name “empname” FROM employees ORDER BY empname;SELECT employee_name emp#name FROM employees ORDER BY emp#name; 〇SELECT employee_name AS Employee_Name FROM employees ORDER BY “Employee_Name”;SELECT employee_name “社員名” FROM employees ORDER BY 社員名; 〇 20、次の表示形式で検索結果を表示させるためには、どの問い合わせを実行しますか。従業員番号 : 1001 従業員氏名 : 山田二郎 SELECT ‘従業員番号 : $employee_id 従業員氏名: $employee_name’, employee_id, employee_name FROM employees;SELECT 従業員番号 : || employee_id || 従業員氏名 : || employee_name FROM employees;SELECT “従業員番号 : “ || employee_id || “ 従業員氏名: “ || employee_name FROM employees;SELECT ‘従業員番号 : ‘ + employee_id + ‘ 従業員氏名: ‘ + employee_name FROM employees;SELECT ‘従業員番号 : ‘ || employee_id || ‘ 従業員氏名 : ‘ || employee_name FROM employees; 〇 21、日付値の特徴として誤っている記述はどれですか(該当するものを全て選択して下さい)。 日付値の表示形式は言語環境により決まっており、変更することはできない 〇日本語環境のデフォルトの表示形式はRR-MM-DDである日付値に対して数値を足したり引いたりできる内部的には文字列で格納されている 〇日付値+日付値の演算はエラーとなる 解説日付値には以下のような特徴があります。 ・日付値は世紀,年,月,日,時,分,秒を表す内部的な数値形式で格納されています。・日付値のデフォルトの表示書式は言語環境により異なりますが、変更することができます。・日付値に対して数値（日数）の加算,減算を行えます。また日付値-日付値で2つの日付値間の日数を求める事もできます。ただし、日付値+日付値の演算はできません。 22、実行結果が”12-04-01”と表示されるのはどの問い合わせですか(該当するものを全て選択して下さい)。ただし、データベースの実行環境は日本語環境とし、日付書式はRR-MM-DDとします。※ 2012年3月26日は月曜日です。 SELECT ADD_MONTHS(‘12-01-01’, 4) FROM dual;SELECT TRUNC(TO_DATE(‘12-04-10’), ‘DD’) FROM dual;SELECT ROUND(TO_DATE(‘12-04-10’), ‘DD’) FROM dual;SELECT LAST_DAY(‘12-03-01’) + 1 FROM dual; 〇SELECT NEXT_DAY(‘12-03-26’, ‘日’) FROM dual; 〇SELECT ROUND(TO_DATE(‘12-04-10’), ‘MONTH’) FROM dual; 〇 23、TRIM関数は、引数で指定された文字列の前後にある削除文字を取り除いた文字列を返します。 TRIM([LEADING | TRAILING | BOTH] [削除文字] FROM 文字列)またはTRIM(文字列) LEADING,TRAILING,BOTHを省略した場合は、文字列の前後の削除文字が取り除かれます。削除文字には任意の1文字を指定できますが、文字列は指定できません。 24、次のSQL文の実行結果として正しいものはどれですか。ただし、日付書式は”RR-MM-DD”とします。 DEFINE date = ‘10-04-01’ SELECT department_id, employee_name, hiredate FROM employees WHERE hiredate &gt; ‘&amp;date’ AND department_id = &id; 「date」と「id」の入力を促される「id」のみ入力を促される 〇「date」は予約語のため、DEFINEコマンドでエラーとなる「date」のみ入力を促される 25、現在の日時は2012年12月12日午後10時28分35秒です。現在時刻を次の形式で表示するには、どのSQL文を実行しますか。ただし、実行環境は日本語環境とします。 2012年12月12日(水) 午後 10時28分35秒 SELECT TO_CHAR(SYSDATE, ‘RRRR”年”MM”月”DD”日 (“DY”)” AM HH”時”MI”分”SS”秒”‘) FROM dual; 〇SELECT TO_CHAR(SYSDATE, ‘YYYY”年”MM”月”DD”日 (“DAY”)” P.M. HH12”時”MI”分”SS”秒”‘) FROM dual;SELECT TO_CHAR(SYSDATE, ‘RRR”年”MM”月”DD”日 (“DY”)” HH12”時”MI”分”SS”秒”‘) FROM dual;SELECT TO_CHAR(SYSDATE, ‘YYY”年”MM”月”DD”日 (“DY”)” PM HH24”時”MI”分”SS”秒”‘) FROM dual; 26、TO_NUMBER関数で文字列を数値に変換します。正しく変換されるものはどれですか。ただし、実行環境は日本語環境とします。 TO_NUMBER(‘$500,000’, ‘L999,999’)TO_NUMBER(‘?500,000’, ‘L99999’)TO_NUMBER(‘?500,000’, ‘999,999’)TO_NUMBER(‘?500,000’, ‘L999,999’) 〇 27、数値書式のうち、負の値に関する書式とその説明として、正しいものはどれですか。 TO_CHAR(-123456, ‘999999’) は 123456 と表示されるTO_CHAR(-123456, ‘999999MI’) は 123456- と表示される 〇TO_CHAR(-123456, ‘999999S’) は -123456 と表示されるTO_CHAR(-123456, ‘999999MI’) は -123456 と表示されるTO_CHAR(-123456, ‘999999PR’) は と表示される 〇TO_CHAR(-123456, ‘999999PR’) は 123456- と表示される 28、各プロモーションの開始日(PROMO_BEGIN_DATE)と終了日(PROMO_END_DATE)が同じだったら、「同日終了」と表示します。どの問合せを使用しますか(該当するものを全て選択して下さい)。 SELECT promo_name, NVL(TO_CHAR(promo_end_date - promo_begin_date), ‘同日終了’) status FROM promotions;SELECT promo_name, NVL2(NULLIF(promo_begin_date, promo_end_date), NULL, ‘同日終了’) status FROM promotions; 〇SELECT promo_name, CASE NULLIF(promo_begin_date, promo_end_date) WHEN NULL THEN ‘同日終了’ END status FROM promotions;SELECT promo_name, DECODE(promo_begin_date - promo_end_date, 0, ‘同日終了’) status FROM promotions; 〇 解説・SELECT promo_name, CASE NULLIF(promo_begin_date, promo_end_date) WHEN NULL THEN ‘同日終了’ END status FROM promotions;単純CASE式ではNULL値の評価はできないため、NULL値の判定はTRUEとならず条件に該当しないことになります。エラーにはなりませんが、「同日終了」が表示されません。NULL値の評価は、検索CASE式でIS NULL演算子を使う必要があります。誤ったSQL文です。 29、次のSQL文の実行結果として、正しいものはどれですか。 SELECT TO_NUMBER(‘-0.75’, ‘0.99999’) * 3 FROM dual; TO_NUMBER関数の結果を用いて演算を行うことはできないため、エラーとなる正常に実行され、-2.25が表示される 〇TO_NUMBER関数の数値書式に-(マイナス)記号が指定されていないため、エラーとなる正常に実行され、2.25が表示される 30、NULLIF関数の説明で正しいものはどれですか(該当するものをすべて選択してください)。 2番目の引数にリテラルNULL値を指定できる 〇2つの値を比較して、等しい場合はNULLを返す 〇2つの値を比較して、等しい場合は第1引数の値を返す2つの値を比較して、異なる場合はNULLを返す1番目の引数にリテラルNULL値を指定できない 〇2つの値を比較して、異なる場合は第2引数の値を返す 31、2009年12月31日以前に入社した従業員と2010年1月1日以降に入社した従業員の年収の合計をそれぞれ求めるために次のSQL文を実行しました。実行結果として正しいものはどれですか。ただし、従業員の年収はSALARY列の12倍にCOMMISSION列の値を加算したものとします。 SELECT SUM(CASE WHEN hiredate &lt; TO_DATE(‘2010-01-01’, ‘YYYY-MM-DD’) THEN salary 12 + commissionELSE NULL END) sum1,SUM(CASE WHEN hiredate &gt;= TO_DATE(‘2010-01-01’, ‘YYYY-MM-DD’) THEN salary 12 + commissionELSE NULL END) sum2FROM employees; 正常に実行でき、期待したデータが表示される 〇関数の中でCASE式を使用することはできないので、エラーとなるCASE式のCASEとWHENの間に式が指定されていないので、エラーとなるCASE式のデフォルトの戻り値にNULL値を指定することはできないので、エラーとなる 解説CASE式には単純CASE式と検索CASE式の2種類がありますが、設問のSQL文で使用されているCASE式は検索CASE式です。 CASE式は関数の引数として記述することもできますし、デフォルトの戻り値にNULL値を指定することもできます。 32、CASE式では、WHEN句で比較条件やINやLIKEなどの演算子が使用できますが、DECODE関数では使用できません。NVL関数の第2引数には、第1引数と同じデータ型の値を指定しなければなりません。COALESCE関数で引数を順番に判定しNULL値以外の値を返そうとしていますが、引数は全て同じデータ型でなければなりません。 33、現在の日付は2012年06月23日です。1999年4月1日から現在までの日数を求めるには、どのSQL文を実行しますか(該当するものをすべて選択してください)。ただし、実行環境は英語環境とし、デフォルトの日付の表示形式は「RR-MM-DD」とします。 SELECT TO_CHAR(SYSDATE) - ‘99-04-01’ FROM dual;SELECT SYSDATE - TO_DATE(‘99-04-01’, ‘RR-MM-DD’) FROM dual; 〇SELECT SYSDATE - TO_DATE(‘01-Apr-99’) FROM dual;SELECT SYSDATE - TO_DATE(‘99-04-01’, ‘YY-MM-DD’) FROM dual;SELECT TO_DATE(SYSDATE, ‘RR-MM-DD’) - TO_DATE(‘99-04-01’, ‘RR-MM-DD’) FROM dual; 〇SELECT SYSDATE - TO_DATE(‘1999-Apr-01’, ‘YYYY-Mon-DD’) FROM dual; 〇 32、日本語環境で日付書式のデフォルト値は「RR-MM-DD」です。例:12-05-21 33、次の2つのSQL文の結果として正しいものはどれですか。 NAME VARCHAR2(20)ENDDATE DATE 1) SELECT NVL(enddate, name) FROM prod; 2) SELECT NVL2(enddate, name, name) FROM prod; 2)はエラーが発生し、1)は正常に実行できる1),2)は正常に実行できるが、異なる結果が出力される1)はエラーが発生し、2)は正常に実行できる 〇1),2)は正常に実行でき、同じ結果が出力される 解説:NVL関数は、第1引数の値がNULL値の場合は第2引数の値を返し、第1引数の値がNULL値以外の場合はそのまま第1引数の値を返します。NVL2関数は、第1引数の値がNULL値以外の場合は第2引数の値を返し、第1引数の値がNULL値の場合は第3引数の値を返します。 また、NVL関数の第2引数に指定する式は、第1引数の式と同じデータ型でなければなりません。NVL2関数の第3引数に指定する式は、第2引数の式と同じデータ型でなければなりませんが、第1引数とは異なるデータ型でも構いません。 34、次のSQL文を確認して下さい。 SELECT employee_id, employee_name, hiredate FROM employees WHERE hiredate &gt;= ‘30-APR-10’; このSQL文に関して正しい記述はどれですか。ただし、データベースの実行環境は日本語環境とし、日付書式は”RR-MM-DD”とします。 正常に実行され全てのデータが表示される正常に実行されるがデータは1件も表示されない正常に実行され該当するデータが表示されるエラーが発生する 〇 Oracle Databaseでは、データ型の変換が意味を持つ場合に、自動的にデータ型の変換が行われます(暗黙的なデータ変換といいます)が、次のような場合にはデータ変換は行われません。 ・数値が期待されている箇所に’abc’などの文字列を指定する・日付書式にあっていない日付リテラルを指定する 設問では、日本語環境で日付書式が”RR-MM-DD”であるのに対し、”DD-MON-RR”の形式で日付リテラルが指定されていますので、暗黙的なデータ変換が行われません。 35、次のSQL文のうち正常に実行されるものはどれですか(該当するものをすべて選択してください)。 SELECT employee_id, employee_name, DECODE(NULLIF(salary, 500000), salary, 250000*1.1, NULL, hiredate) sal FROM employees;SELECT employee_id, employee_name, DECODE(NULLIF(salary, 500000), NULL, ‘-‘, salary) sal FROM employees; 〇SELECT employee_id, employee_name, DECODE(NULLIF(salary, 500000), NULL, salary, ‘-‘) sal FROM employees;SELECT employee_id, employee_name, DECODE(salary, salary &gt; 400000, ‘High’, salary &lt; 200000, ‘low’, ‘middle’) sal FROM employees;SELECT employee_id, employee_name, DECODE(salary, NULL, 150000) sal FROM employees; 〇 解説:DECODE関数の条件に、WHERE句の条件に指定するような比較演算子を使用した条件を記述することはできません。また、条件が複数指定された場合の戻り値のデータ型は、第3引数で指定された戻り値のデータ型が採用されます。したがってそれぞれの戻り値は、第3引数の戻り値のデータ型と同じデータ型の値を指定するか、暗黙的なデータ変換で第3引数の戻り値のデータ型と同じデータ型となるような値を指定しなければなりません。 ・SELECT employee_id, employee_name, DECODE(NULLIF(salary, 500000), NULL, ‘-‘, salary) sal FROM employees;上記のSQL文で、DECODE関数に指定された第3引数は文字データ(‘-‘)であるのに対し、デフォルトの戻り値として数値データ(salary)が指定されています。データ型が異なるのにエラーとならずに正常に実行できるのは、数値データが暗黙的データ変換により文字データに変換されるためです。 36、データ型の変換に関して正しい記述はどれですか(該当するものを全て選択して下さい)。 データ型を変換する場合は必ず変換関数で変換しなければならないTO_NUMBER関数は文字列または日付値を数値に変換するTO_CHAR関数は数値または日付値を文字列に変換する 〇日付値を数値に変換する関数はない 〇TO_DATE関数は数値を日付値に変換する 解説:・TO_CHAR：数値や日付値を文字列に変換する・TO_DATE：文字列を日付値に変換する・TO_NUMBER：文字列を数値に変換する 37、COALESCE関数で引数を順番に判定しNULL値以外の値を返そうとしていますが、引数は全て同じデータ型でなければなりません。 38、次のSQL文のうち、正常に実行されるものはどれですか(該当するものを全て選択して下さい)。ただし、日付書式は”RR-MM-DD”とします。 SELECT startdate + ‘12-01-01’ FROM prod;SELECT startdate + ‘10’ FROM prod; 〇SELECT FROM prod WHERE startdate = ‘10-01-30’; 〇SELECT ‘name:’ + name FROM prod;SELECT FROM prod WHERE startdate &gt; ‘05/01/01’; 〇 解説:・SELECT * FROM prod WHERE startdate &gt; ‘05/01/01’;WHERE句に指定された文字リテラルが暗黙的データ変換でDATE型の値に変換され、条件に該当する列が取り出されます。ここで、日付書式が”RR-MM-DD”であるのに、文字リテラルを”RR/MM/DD”の形式として、異なる区切り文字で指定しています。しかしOracle Databaseは区切り文字に関して一定の柔軟性を持って変換しますので、エラーとはなりません。 39、複数行副問合せに関する説明として、正しいものはどれですか(該当するものを全て選択して下さい)。 複数行副問合せではGROUP BY句を指定することはできない複数行副問合せをネストすることができる 〇複数の列を返すこともできる 〇複数行副問合せではグループ関数をネストすることができない複数行副問合せは1件のデータを返す複数行副問合せは複数件のデータを返す 〇 40、副問合せに関する説明として、正しいものはどれですか(2つ選択して下さい)。 必ず副問合せが実行された後で主問合せが実行される複数行副問合せの比較演算子に単一行演算子=を使用するとエラーとなる 〇必ず主問合せが実行された後で副問合せが実行される副問合せは必ず比較演算子の右側に指定するSELECT文で使用する副問合せは()括弧で囲む 〇 41、MINUS演算子に関する説明として、誤っているものはどれですか。 問合せの結果にNULL値が含まれている場合は、NULL値も表示する問合せの結果がソートされる1つ目の問合せと2つ目の問合せの順序を逆にしても結果は同じになる 〇2つの問合せのSELECT句に指定する列や式の数は同じにする 42、次の問合せのうち、正しく実行されるものはどれですか(該当するものを全て選択して下さい)。 SELECT department_id dept FROM departments UNION SELECT employee_id emp FROM employees ORDER BY emp;SELECT department_id FROM departments UNION SELECT employee_id FROM employees ORDER BY department_id; 〇SELECT department_id FROM departments ORDER BY department_id UNION SELECT employee_id FROM employees;SELECT department_id FROM departments UNION SELECT employee_id FROM employees ORDER BY employee_id;SELECT department_id dept FROM departments UNION SELECT employee_id emp FROM employees ORDER BY dept; 〇 解説集合演算子を用いて複合問合せを行う際にORDER BY句を指定する場合は、次のガイドラインに従います。 ・ORDER BY句は複合問合せの最後の問合せに指定する・ORDER BY句には最初の問合せに指定されている列名や列別名を指定する 43.MERGE文の説明として正しいものはどれですか(該当するものを全て選択して下さい)。 他の表とデータを入れ替える行の挿入と更新を同時に行える 〇DML文に分類される 〇DDL文に分類される 解説MERGE文は異なる表の行をマージできるDML文です。1つのMERGE文で、該当する行があればUPDATE、無ければINSERTというように、行の挿入と更新を同時に行えます。MERGE文は次のように使用します。 44.PROD表の全てのデータを削除するには、どのSQL文を実行しますか(該当するものをすべて選択してください)。 TRUNCATE FROM prod;TRUNCATE TABLE prod WHERE prodid &gt; 1;TRUNCATE TABLE prod; 〇DELETE FROM prod WHERE prodid = 1;DELETE FROM prod; 〇DELETE prod; 〇 解説表の全てのデータを削除するには、DELETE文を削除する行の条件を指定せずに実行するか、TRUNCATE文を実行します。 DELETE文のFROMキーワードは省略が可能です。 45.自動ロールバックされるイベントとして、正しいものはどれですか(該当するものを全て選択して下さい)。 システム障害時 〇SAVEPOINT文実行時EXIT文でSQL Plus終了時SQL Plusの異常終了時 〇DDL文実行時 解説Oracle Databaseでは次の場合に自動ロールバックされます。・システム障害が発生した場合・SQL *Plusを×ボタンで終了した時など異常終了した場合 46.次のSQL文の実行結果として、正しいものはどれですか。 DELETE (SELECT department_id, employee_id FROM employees) WHERE salary &gt; 400000; 表名の代わりに指定した副問合せのSELECT句に指定された列しかWHERE句に指定できないため、エラーとなる 〇DELETE文では副問合せは使用できないため、エラーとなる正常に実行されるが、行は削除されない正常に実行され、行が削除される 47.排他ロックに関する説明として、正しいものはどれですか。 排他ロックでは表全体がロックされるロックがかかっている行に対して、DELETE文を実行すると待機せずに処理される他のユーザーが更新中のデータを参照した場合、更新が完了するまで待機させられるINSERT、UPDATE、DELETE文実行時、Oracleサーバーは排他ロックをかける 〇 解説Oracle Databaseは複数のユーザーが同時に同じ行に対して変更処理(INSERT,UPDATE,DELETE)を行った場合に、データの矛盾が生じないよう、行毎に排他ロックをかけて変更処理を行います。排他ロックがかかっている行に対して変更処理を行おうとすると、排他ロックが解除されるまで待機させられます。排他ロックはトランザクションの終了時に解除されます。 以上より、・INSERT、UPDATE、DELETE文実行時、Oracleサーバーは排他ロックをかけるが正解となります。 その他の選択肢については次のとおりです。 ・他のユーザーが更新中のデータを参照した場合、更新が完了するまで待機させられる更新中のデータを他のユーザーが参照した場合、UNDOセグメントにコピーされた変更前のデータが返されます。 ・排他ロックでは表全体がロックされる行毎にロックされます ・ロックがかかっている行に対して、DELETE文を実行すると待機せずに処理されるロックがかかっている行に対して変更処理(INSERT,UPDATE,DELETE)を行うとロックが解除されるまで待機させられます。 48.次のSQL文の説明として正しいものはどれですか(該当するものを全て選択して下さい)。 TRUNCATE TABLE employees; 表が使用していた領域が解放される 〇表のデータが全て削除される 〇表に作成されている索引が削除されるロールバック情報が生成される削除トリガーが実行される 49.NUMBER型の説明として、正しいものはどれですか。 データ型がNUMBER(5)の列に123.45を入力すると、123.45が格納される 123データ型がNUMBER(3,-1)の列に123.45を入力すると、120が格納される 〇データ型がNUMBER(5,-2)の列に123.456を入力すると、123.46が格納される 100データ型がNUMBERの列に12.345を入力すると、12.345が格納される 〇データ型がNUMBER(3,1)の列に123.45を入力すると、123.5が格納される 格納することはできません 50.順序に関する説明として、正しいものはどれですか(該当するものを全て選択して下さい)。 欠番が発生する場合もある 〇1つの順序を複数の表で使用できる 〇ユーザー毎に一意な番号を生成する 〇複数のユーザーで共有可能である連番が保証されている 51.ビューを利用する目的は次の通りです。 ・データへのアクセス制御・複雑なSQL文の簡素化・データの独立性を確保・同じデータを異なる視点で表示 52.順序に関する説明として、正しいものはどれですか(該当するものを全て選択して下さい)。 順序は複数の表で共有できない順序値の最大値は後から変更できないセッション開始後、CURRVAL疑似列を参照する前にNEXTVAL疑似列を参照しなければならない 〇順序を削除する場合は、DROP SEQUENCE文で削除する 〇キャッシュにある未使用の順序値は、クラッシュして再起動した後も使用できる 53.シノニムに関する説明として、誤っているものはどれですか。 オブジェクトの別名であるパブリックシノニムと同名のプライベートシノニムを作成できるパブリックシノニムとプライベートシノニムではパブリックシノニムが優先される 〇セキュリティを高める 54.順序に関する説明として、正しいものはどれですか(該当するものを2つ選択して下さい)。 初期値のデフォルト値は1である 〇増分値を指定することができる 〇順序を参照するたびに順序値が生成される順序の増分値に負の値を指定できない順序の値が最大値に達した後は必ず順序値の生成を終了する]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>奋斗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Study 1]]></title>
    <url>%2FC-Study.html</url>
    <content type="text"><![CDATA[C#基礎知識 一、Hashtableクラスの使い方123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124①【用途】キーと値をセットにして要素を作成する場合に使う【Hashtableの宣言】using System.Collections;Hashtable hash = new Hashtable();【Hashtableへ要素を追加する】hash[キー] = 値;※キーが無ければ追加、有れば上書きされるhash.add(キー, 値);※キーが無ければ追加、有ればArgumentExceptionが発生する【Hashtableから要素を削除する】hash.remove(キー);【Hashtableの要素を取得する】string str = hash[&quot;key1&quot;].ToString();【同じキーが存在するか確認する】bool ret = hash.ContainsKey(キー);【同じ値が存在するか確認する】bool ret = hash.ContainsValue(値);【キーを取得しリストボックスへ表示する】foreach(string key in hash.Keys)&#123; this.listbox1.Add(key);&#125;【値を取得しリストボックスへ表示する】foreach(string val in hash.Values)&#123; this.listbox1.Add(val);&#125;【キーと値を取得しリストボックスへ表示する】foreach(System.Collections.DictionaryEntry de in hash)&#123; this.listbox1.Add(de.Key + &quot; &quot; + de.Value);&#125;②using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace Hashtable_study&#123; class Program &#123; static void Main(string[] args) &#123; //Hashtableのキーと値取得 Hashtable ht = new Hashtable(); ht[&quot;a&quot;] = &quot;aaa&quot;; ht[&quot;b&quot;] = &quot;bbb&quot;; ht[&quot;c&quot;] = &quot;ccc&quot;; foreach (DictionaryEntry h in ht) &#123; Console.WriteLine(&quot;キー:&#123;0&#125; 値:&#123;1&#125;&quot;, h.Key, h.Value); &#125; //昇順でHashtableの値取得 Hashtable ht2 = new Hashtable(); ht2.Add(2,&quot;two&quot;); ht2.Add(1,&quot;one&quot;); ht2.Add(3, &quot;three&quot;); ArrayList keys = new ArrayList(ht2.Keys); keys.Sort(); foreach (var key in keys) &#123; Console.WriteLine(ht2[key]); &#125; //Array.Sortで配列のソート int[] src = &#123; 3,1,4,5,2&#125;; Array.Sort(src); Console.WriteLine(&quot;[&#123;0&#125;]&quot;,string.Join(&quot;,&quot;,src)); //list.SortでListのソート int[] src2 = &#123; 3, 1, 4, 5, 2 &#125;; var list = new List&lt;int&gt;(); //listに要素を追加 list.AddRange(src2); list.Sort(); Console.WriteLine(&quot;[&#123;0&#125;]&quot;, string.Join(&quot;, &quot;, list));//ここ要注意src2ではなく、listです。 //暗黙型付け配列 var array = new[] &#123; new &#123;X = 0, Y = 1&#125;, new &#123;X = 3, Y = -1&#125;, new &#123;X = 7, Y = 3&#125;, new &#123;X = 13, Y = -5&#125;, &#125;; foreach (var p in array) Console.WriteLine(&quot;&#123;0&#125;\n&quot;, p); Console.ReadKey(); &#125; &#125;&#125; 二、オーバーライドとオーバーロード12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace オーバーライドとオーバーロード&#123; /// &lt;summary&gt; /// オーバーライド /// オーバーライドとは、スーパークラスのメソッドを上書きする /// &lt;/summary&gt; public class オーバーライド &#123; public virtual void Mothed1() &#123; Console.WriteLine(&quot;1&quot;); &#125; &#125; public class オーバーライド2 : オーバーライド &#123; public override void Mothed1() &#123; base.Mothed1(); Console.WriteLine(&quot;2&quot;); &#125; &#125; /// &lt;summary&gt; /// オーバーロード /// オーバーロードとは、「引数や戻り値が異なるが名称が同一のメソッドを複数定義する」というオブジェクト指向プログラミングのテクニックである。 /// &lt;/summary&gt; public class オーバーロード &#123; public virtual void Method1() &#123; Console.WriteLine(&quot;1&quot;); &#125; public void Mothod1(int a) &#123; Console.Write(a); &#125; &#125;&#125; 三、抽象クラスと多態性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267①using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace abstractclass&#123; abstract class Person &#123; protected string name; protected int age; public Person(string name,int age) &#123; this.name = name; this.age = age; &#125; public string Name &#123; get &#123; return this.name; &#125; &#125; public abstract int Age &#123; get; &#125;//抽象メソッドには定義は要らない &#125; /// &lt;summary&gt; /// 正直者 /// 年齢を偽らない /// &lt;/summary&gt; class Truepenny : Person &#123; public Truepenny(string name,int age) : base(name, age) &#123; &#125; public override int Age &#123; get &#123; //実年齢をそのまま返す return this.age; &#125; &#125; &#125; /// &lt;summary&gt; /// 嘘つき。 /// 鯖を読む(しかも、歳取るにつれ大幅に)。 /// &lt;/summary&gt; class Liar : Person &#123; public Liar(string name, int age) : base(name, age) &#123; &#125; public override int Age &#123; get &#123; // 年齢を偽る。 if (this.age &lt; 20) return this.age; if (this.age &lt; 25) return this.age - 1; if (this.age &lt; 30) return this.age - 2; if (this.age &lt; 35) return this.age - 3; if (this.age &lt; 40) return this.age - 4; return this.age - 5; &#125; &#125; &#125; /// &lt;summary&gt; /// いいかげん。 /// 大体の歳しか答えない。 /// &lt;/summary&gt; class Equivocator : Person &#123; public Equivocator(string name, int age) : base(name, age) &#123; &#125; public override int Age &#123; get &#123; // 年齢を四捨五入した値を返す。 return ((this.age + 5) / 10) * 10; &#125; &#125; &#125; /// &lt;summary&gt; /// いくつになったって気持ちは17歳。 /// &lt;/summary&gt; class Seventeenist : Person &#123; public Seventeenist(string name, int age) : base(name, age) &#123; &#125; public override int Age &#123; get &#123; // 「おいおい」って突っ込み入れてあげてね。 return 17; &#125; &#125; &#125; class PolymorphismTest &#123; static void Main() &#123; Introduce(new Truepenny (&quot;Ky kiske&quot; ,24));//正直者のカイさん24歳。 Introduce(new Liar(&quot;Axl Low&quot;, 24));//嘘つきのアクセルさん24歳。 Introduce(new Equivocator(&quot;Sol Badguy&quot;, 24)); //いい加減なソルさん24歳。 Introduce(new Seventeenist(&quot;Ino&quot;, 24));// 時空を超えるイノさん24歳。 Console.ReadKey(); &#125; ///&lt;summary&gt; ///自己紹介する ///&lt;/summary&gt; static void Introduce(Person p) &#123; Console.Write(&quot;My name is &#123;0&#125;.\n&quot;, p.Name); Console.WriteLine(&quot;I&apos;m &#123;0&#125; years old.\n&quot;, p.Age); &#125; &#125;&#125;②using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace abstractclass&#123; abstract class Bird &#123; //名前フィールド private string name; //引数つきコンストラクタ public Bird(string name) &#123; this.name = name; &#125; //名前を取得 public String Name &#123; get &#123;return name;&#125; &#125; //鳴く(抽象メソッド) public abstract void Sing(); &#125; class Sparrow : Bird &#123; //コンストラクタ public Sparrow() : base(&quot;すずめ&quot;) &#123; &#125; //すずめが鳴く public override void Sing() &#123; Console.WriteLine(&quot;チュンチュン&quot;); &#125; &#125; class Crow : Bird &#123; //コンストラクタ public Crow() : base(&quot;カラス&quot;) &#123; &#125; //カラスが鳴く public override void Sing() &#123; Console.WriteLine(&quot;カーカー&quot;); &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Crow c = new Crow(); Sparrow s = new Sparrow(); //カラスが鳴く Console.Write(c.Name + &quot;:&quot;); c.Sing(); //すずめが鳴く Console.Write(s.Name + &quot;:&quot;); s.Sing(); &#125; &#125;&#125;※※※※※※※※※※※※※※※※※※※※※※以上のProgramを以下のように変えられる。class Program&#123; static void Main(string[] args) &#123; Bird[] b = new Bird[2]; b[0] = new Crow(); b[1] = new Sparrow(); for(int i = 0; i &lt; b.Length ; i ++) &#123; Console.Write(b[i].Name + &quot;:&quot;); b[i].Sing(); &#125; &#125;&#125;③namespace abstractproperty&#123; abstract class VectorBase &#123; public abstract double X &#123; set; get; &#125; public abstract double Y &#123; set; get; &#125; &#125; class Vector : VectorBase &#123; private double x = 0.0; private double y = 0.0; //プロパティの実装 public override double X &#123; set &#123; x = value;&#125; get &#123; return x; &#125; &#125; public override double Y &#123; set &#123; y = value;&#125; get &#123; return y;&#125; &#125; &#125; class Program &#123; static void Main(string[] args) &#123; Vector v = new Vector(); v.X = 0.1; v.Y = 0.2; Console.WriteLine(&quot;v=(&#123;0&#125;,&#123;1&#125;)&quot;,v.X,v.Y); &#125; &#125;&#125; 四、列挙12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667①using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace EnumClass&#123; [Flags] enum Flag:int &#123; X = 1, Y , Z &#125; class EnumClass &#123; static void Main(string[] args) &#123; Flag f = Flag.X | Flag.Y; if (f.HasFlag(Flag.X)) &#123; Console.WriteLine((int)Flag.X); &#125; else &#123; Console.WriteLine(&quot;null&quot;); &#125; foreach (string name in typeof(Flag).GetEnumNames()) &#123; Console.WriteLine(name); &#125; foreach (Flag val in typeof(Flag).GetEnumValues()) &#123; Console.WriteLine((int)val); &#125; for (int i = 1; i &lt; 4; i++) &#123; Console.Write(&quot;&#123;0&#125;月 &#123;1&#125;\n&quot;, i, (Flag)i); &#125; Console.ReadKey(); &#125; &#125;② enum Month : byte &#123; January = 1, February, March, April, May, June, July, August, September, October, November, December &#125; class EnumSample &#123; static void Main() &#123; for (int i = 1; i &lt; 12; ++i) Console.Write(&quot;&#123;0&#125;月 &#123;1&#125;\n&quot;, i, (Month)i); Console.ReadKey(); &#125; &#125;&#125; 五、委託123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102①using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace デリケート_delegate&#123; public delegate void GreetingDelegate(string name,int age); class Program &#123; static void EnglishGreeting(string name,int age) &#123; Console.WriteLine(&quot;&#123;0&#125;,GoodMorning!I&apos;m &#123;1&#125; years old.&quot;, name,age); &#125; static void ChineseGreeting(string name,int age) &#123; Console.WriteLine(&quot;&#123;0&#125;,早上好！我今年 &#123;1&#125; ?了。&quot;, name,age); &#125; static void GreetPeople(string name, int age,GreetingDelegate MakeGreeting) &#123; MakeGreeting(name,age); &#125; static void Main(string[] args) &#123; GreetPeople(&quot;Zhou hengheng&quot;,11,EnglishGreeting); GreetPeople(&quot;周&quot;,22,ChineseGreeting); Console.ReadKey(); &#125; &#125;&#125;②delegate void CallbackMethod();class Test&#123; static void Main() &#123; //従来のデリゲートインスタンス生成式 CallbackMethod callback = new CallbackMethod(Method1); callback(); //C#2.0のデリゲートインスタンス生成式 callback = Method2; callback(); &#125; static void Method1() &#123; System.Console.WriteLine(&quot;Method 1&quot;); &#125; static void Method2() &#123; System.Console.WriteLine(&quot;Method 2&quot;); &#125;&#125;③namespace WindowsApplication1&#123; delegate void Delg() public class X &#123; public void C() &#123; MessageBox.Show(&quot;C&quot;); &#125; &#125; public partial class Form1:Form &#123; static void A() &#123; MessageBox.Show(&quot;A&quot;); &#125; static void B() &#123; MessageBox.Show(&quot;B&quot;); &#125; public Form1() &#123; InitializeComponent(); Delg del; del = new Delg(A);//デリゲートにメソッドAの参照を代入 del += new Delg(B);//デリゲートにメソッドBの参照を追加 X x = new X();//別classのメソッドXの実例化 del += new Delg(x.C);//デリゲートにメソッドCの参照を追加 del(); &#125; &#125;&#125; 六、コンストラクターとデストラクター12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576using System;/// &lt;summary&gt;/// 名簿用の個人情報記録用のクラス。/// とりあえず、名前と年齢のみ。/// &lt;/summary&gt;class Person&#123; // public なフィールド public string name; // 氏名 public int age; // 年齢 // 定数 const int UNKNOWN = -1; const string DEFAULT_NAME = &quot;デフォルトの名無しさん&quot;; /// &lt;summary&gt; /// 名前と年齢を初期化 /// 与えられた年齢が負のときは年齢不詳とみなす /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;氏名&lt;/param&gt; /// &lt;param name=&quot;age&quot;&gt;年齢&lt;/param&gt; public Person(string name, int age) &#123; this.name = name; this.age = age &gt; 0 ? age : UNKNOWN; &#125; /// &lt;summary&gt; /// 名前のみを初期化 /// 年齢は不詳とする /// &lt;/summary&gt; /// &lt;param name=&quot;name&quot;&gt;氏名&lt;/param&gt; public Person(string name) : this(name, UNKNOWN) &#123; &#125; /// &lt;summary&gt; /// デフォルトコンストラクター /// 氏名・年齢ともに不詳 /// &lt;/summary&gt; public Person() : this(null, UNKNOWN) &#123; &#125; /// &lt;summary&gt; /// 文字列化 /// 氏名が不詳のときには NONAME に設定された名前を返す /// 年齢が不詳の時には名前のみを返す /// 氏名・年齢が分かっているときには「名前(xx歳)」という形の文字列を返す /// &lt;/summary&gt; public override string ToString() &#123; if(name == null) return DEFAULT_NAME; if(age == UNKNOWN) return name; return name + &quot;(&quot; + age + &quot;歳)&quot;; &#125;&#125;//class Person//----------------------------------------------------// メインプログラムclass ConstructorSample&#123; static void Main() &#123; Person p1 = new Person(&quot;ちゆ&quot;, 12); Person p2 = new Person(&quot;澪&quot;); Person p3 = new Person(); Console.Write(&quot;&#123;0&#125;\n&#123;1&#125;\n&#123;2&#125;\n&quot;, p1, p2, p3); &#125;&#125; 七、List12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364①Addで要素を追加するusing System;using System.Collections.Generic;namespace Sample&#123; class Sample &#123; static void Main() &#123; var list = new List&lt;string&gt;(); list.Add(&quot;Tokyo&quot;); list.Add(&quot;Osaka&quot;); list.Add(&quot;Nagoya&quot;); Console.WriteLine(&quot;[&#123;0&#125;]&quot;, string.Join(&quot;, &quot;, list)); Console.ReadKey(); &#125; &#125;②AddRangeで要素を追加するusing System;using System.Collections.Generic;namespace Sample&#123; class Sample &#123; static void Main() &#123; string[] src = &#123;&quot;Tokyo&quot;, &quot;Osaka&quot;, &quot;Nagoya&quot;&#125;; var list = new List&lt;string&gt;(); list.AddRange(src); Console.WriteLine(&quot;[&#123;0&#125;]&quot;, string.Join(&quot;, &quot;, list)); Console.ReadKey(); &#125; &#125;③Removeで要素を削除するusing System;using System.Collections.Generic;namespace Sample&#123; class Sample &#123; static void Main() &#123; var list = new List&lt;string&gt;(); list.Add(&quot;Tokyo&quot;); list.Add(&quot;Osaka&quot;); list.Add(&quot;Nagoya&quot;); list.RemoveRange(1, 2); Console.WriteLine(&quot;[&#123;0&#125;]&quot;, string.Join(&quot;, &quot;, list)); Console.ReadKey(); &#125; &#125;&#125; 八、ファイル読込むと書込む12345678910111213141516171819202122232425262728using System;using System.IO;using System.Text;class FileRead&#123; static void Main() &#123; StreamReader sr = new StreamReader(&quot;readme.txt&quot;,Encoding.GetEncoding(&quot;Shift_JIS&quot;)); string text = sr.ReadToEnd(); sr.Close(); Console.Write(text); &#125;&#125;using System;using System.IO;using System.Text;class FileWrite&#123; static void Main(string[] args) &#123; StreamWriter writer = new StreamWriter(@&quot;C:\Test.txt&quot;,true,Encoding.GetEncoding(&quot;Shift_JIS&quot;)); writer.WriteLine(&quot;テスト書込みです。&quot;); writer.Close(); &#125;&#125; 九、メール送信1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374①using System.Net.Mail;using System.Net.Sockets;using System.IO;private void button1_Click(object sender , EventArgs e)&#123; TcpClient tcp = new TcpClient(); StreamWriter wr = null; string send = &quot;USER ユーザー名\n PASS パスワード\nShuu\n&quot;; try &#123; //POPサーバーに接続する tcp.Connect(&quot;POPサーバー&quot;,110); //認証用のユーザー名とパスワードをストリームに送る wr = new StreamWriter(tcp.GetStream()); wr.Write(send); SmtpClient sm = new SmtpClient(&quot;SMTPサーバー&quot;); //件名と本文を送信する sm.Send(&quot;差出人メールアドレス&quot;, textBox1.Text,//送信先のメールアドレス textBox2.Text,//件名 textBox3.Text);//メール本文 label2.Text = &quot;送信しました。&quot;; &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; finally &#123; wr.Close(); tcp.Close(); &#125;&#125;②MailMessageオブジェクトでメール送信public void SendMail()&#123; System.Net.Mail.MailMessage msg = new System.Net.Mail.MailMessage(); //送信者 msg.From = new System.Net.Mail.MailAddress(&quot;sender@XXX.XXX&quot;,&quot;佐藤&quot;); //宛先 msg.To.Add(new System.Net.Mail.MailAddress(&quot;recipient@xxx.xxx&quot;,&quot;加藤&quot;))； //件名 msg.Subject = &quot;こんにちは&quot;; //本文 msg.Body = &quot;-----&quot;; try &#123; System.Net.Mail.SmtpClient sc = new System.Net.Mail.SmtpClient(); //SMTPサーバーなどを設定する sc.Host = &quot;localhost&quot;; sc.Port = 25; sc.DeliveryMethod = System.Net.Mail.SmtpDeliveryMethod.NetWork; //メッセージを送信する sc.Send(msg); &#125; catch (Exception ex) &#123; MessageBox.Show(ex.Message); &#125; finally &#123; //後始末 msg.Dispose(); sc.Dispose(); &#125;&#125; 十、interface 接口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091①public interface Kihon&#123; void print();//メソッドの定義のみ&#125;class Hasei:Kihon&#123; int a; public void print() &#123; Console.WriteLine(&quot;印刷しました。&quot;); &#125;&#125;class main_program&#123; public static void Main() &#123; Hasei pri = new Hasei(); pri.print(); &#125;&#125;②using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace interface_test&#123; //インタフェースの定義 interface IPhone &#123; void Call(string number); &#125; interface IEmail &#123; void SendMail(string address); &#125; class CellPhone : IPhone,IEmail &#123; //メールアドレス private string mailAddress; //電話番号 private string number; //コンストラクタ(メールアドレスと電話番号を設定) public CellPhone(string mailAddress, string number) &#123; this.mailAddress = mailAddress; this.number = number; &#125; //指定した番号に電話を掛ける public void Call(string number) &#123; Console.WriteLine(number + &quot;に、&quot; + this.number + &quot;から電話をかけます。&quot;); &#125; //指定したメールアドレスにメールを送信する public void SendMail(string address) &#123; Console.WriteLine(adress + &quot;に、&quot; + this.mailAddress + &quot;からメールを出します。&quot;); &#125; &#125; class main_program &#123; static void Main(string[] args) &#123; //携帯電話クラスで、電話とメールをする CellPhone cp = new CellPhone(&quot;zhou@yahoo.co.jp&quot;,&quot;080-1234-5678&quot;); cp.Call(&quot;011-1234-5678&quot;); cp.SendMail(&quot;zhouheng@gmail.com&quot;); //電話インタフェースでインスタンスにアクセス。 IPhone phone = (IPhone)cp; phone.Call(&quot;022-1234-5678&quot;); //メールインタフェースでインスタンスにアクセス IEmail mail = (IEmail)cp; mail.SendMail(&quot;zhouheng99@gmail.com&quot;); &#125; &#125;&#125; 十一、静的なメンバ123456789101112131415161718192021222324252627282930313233343536373839using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace test&#123; class Program &#123; //staticなフィールド private static int snum = 100; //インスタンスフィールド public int inum = 200; //staticなメソッド public static void foo() &#123; Console.WriteLine(&quot;fooメソッド(staticメソッド)&quot;); &#125; //インスタンスメソッド public void bar() &#123; Console.WriteLine(&quot;barメソッド(インスタンスメソッド)&quot;); &#125; static void Main(string[] args) &#123; //インスタンスの生成 Program p = new Program(); Console.WriteLine(&quot;pのインスタンスフィールド:inum = &#123;0&#125;&quot;,p.inum); Console.WriteLine(&quot;Programのクラスフィールド:snum = &#123;0&#125;&quot;,snum); foo(); p.bar(); &#125; &#125;&#125; 十二、データを重複なく管理する方法―HashSetクラス123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace test&#123; static void Main(string[] args) &#123; //ハッシュセットの生成 HashSet&lt;int&gt; t = new HashSet&lt;int&gt;(); t.Add(1); t.Add(2); t.Add(3); t.Add(1); //データの出力 foreach (int i in t) &#123; Console.WriteLine(&quot;&#123;0&#125;&quot;,i); &#125; &#125;&#125;結果:1 2 3 十三、トランザクション 事務123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899①private static void ExecuteSqlTransaction(string connectionString)&#123; using (SqlConnection conn = new SqlConnection(connectionString)) &#123; conn.Open(); SqlCommand command = conn.CreateCommand(); //ここは要注意 SqlTransaction trans = conn.BeginTransaction(); command.Connection = conn; command.Transaction = trans; try &#123; command.CommandText = &quot;Insert into Region (RegionID,RegionDescription) VALUES (&quot;100&quot;,&quot;DESCRIPTION&quot;)&quot;; command.ExecuteNonQuery(); trans.Commit(); Console.WriteLine(&quot;データの挿入しました。&quot;); &#125; catch (Exception ex) &#123; trans.Rollback(); Console.WriteLine(&quot;データの挿入が失敗しました。&quot; + ex.Message); &#125; finally &#123; conn.Close(); &#125; &#125;&#125;②using System;using System.Configuration;using System.Data.SqlClient;public void Insert(string id, string password, string phone, string address)&#123; //接続文字列の取得 var connectionString = ConfigurationManager.ConnectionString[&quot;sqlsvr].ConnectionString; using (var conn = new SqlConnection(connectionString)) &#123; try &#123; //データベースの接続開始 connection.Open(); using (var trans = connection.BeginTransaction()) using (var command = new SqlCommand() &#123;Connection = conn ,Transaction = trans&#125;) &#123; try &#123; //親テーブルを挿入するSQLの準備 command.CommandText = @&quot;INSERT INTO T_USER (ID,PASSWORD) VALUES (@ID,@PASSWORD)&quot;; command.Parameters.Add(new SqlParameter(&quot;@ID&quot;,id)); command.Parameters.Add(new SqlParameter(&quot;@PASSWORD&quot;,password)); //親テーブルを挿入するSQLの実行 command.ExecuteNonQuery(); //子テーブルを挿入するSQLの準備 command.CommandText = @&quot;INSERT INTO T_USER_EXT (ID,PHONE,ADDRESS) VALUES (@ID,@PHONE,@ADDRESS)&quot;; command.Parameters.Add(new SqlParater(&quot;@PHONE&quot;,phone)); command.Parameters.Add(new SqlParater(&quot;@ADDRESS&quot;,address)); //子テーブルを挿入するSQLの実行 command.ExecuteNonQuery(); //コミット trans.Commit(); &#125; catch &#123; trans.Rollback(); throw; &#125; &#125; &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); throw; &#125; finally &#123; //データベースの接続終了 conn.Close(); &#125; &#125;&#125;※厳密さを考えずに、一言で言うと、・ExecuteReader select の時使う・ExecuteNonQuery update, insert, delete など更新系の時使う 十四、非同期操作を用いて、一度に複数のクエリを処理する(未習得)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using System.Threading;using System.Data.SqlClient;static void Main(string[] args)&#123; string ConnectionString = @&quot;Data Source=.;Integrated Security=SSPI;&quot; + &quot;Initial Catalog=Northwind;&quot; + &quot;Asynchronous Processing=true&quot;; using(SqlConnection cn1 = new SqlConnection(ConnectionString)) using(SqlConnection cn2 = new SqlConnection(ConnectionString)) using(SqlConnection cn3 = new SqlConnection(ConnectionString)) &#123; string commandText1 = &quot;WAITFOR DELAY &apos;0:0:10&apos;;&quot; + &quot;SELECT * FROM Products WHERE ProductID = 10&quot;; string commandText2 = &quot;WAITFOR DELAY &apos;0:0:00&apos;;&quot; + &quot;SELECT * FROM Products WHERE ProductID = 20&quot;; string commandText3 = &quot;WAITFOR DELAY &apos;0:0:05&apos;;&quot; + &quot;SELECT * FROM Products WHERE ProductID = 30&quot;; cn1.Open(); SqlCommand cmd1 = new SqlCommand(commandText1, cn1); IAsyncResult rst1 = cmd1.BeginExecuteReader(); WaitHandle wH1 = rst1.AsyncWaitHandle; cn2.Open(); SqlCommand cmd2 = new SqlCommand(commandText2, cn2); IAsyncResult rst2 = cmd2.BeginExecuteReader(); WaitHandle wH2 = rst2.AsyncWaitHandle; cn3.Open(); SqlCommand cmd3 = new SqlCommand(commandText3, cn3); IAsyncResult rst3 = cmd3.BeginExecuteReader(); WaitHandle wH3 = rst3.AsyncWaitHandle; WaitHandle[] waitHandles = &#123; wH1, wH2, wH3 &#125;; int index; for (int countWaits = 0; countWaits &lt;= 2; countWaits++) &#123; index = WaitHandle.WaitAny(waitHandles, 10000, false); switch (index) &#123; case 0: SqlDataReader dr1 = cmd1.EndExecuteReader(rst1); DisplayReader(dr1); break; case 1: SqlDataReader dr2 = cmd2.EndExecuteReader(rst2); DisplayReader(dr2); break; case 2: SqlDataReader dr3 = cmd3.EndExecuteReader(rst3); DisplayReader(dr3); break; case WaitHandle.WaitTimeout: throw new Exception(&quot;タイムアウト&quot;); &#125; &#125; &#125;&#125;static void DisplayReader(SqlDataReader dr)&#123; if (dr.Read()) &#123; Console.WriteLine(dr[1].ToString() + &quot;\t&quot; + DateTime.Now.ToLongTimeString()); &#125; dr.Close();&#125; 十五、ExecuteScalarの使い方12345678910111213141516171819202122232425262728293031323334353637383940414243444546①using System.Data.SqlClient;static void Main(string[] args)&#123; using (sqlConnection conn = new SqlConnection()) &#123; conn.ConnectionString = &quot;Data Source=.;Initial Catalog=NorthWind;Intergrated Security=True&quot;; conn.Open(); SqlCommand command = new SqlCommand(&quot;SELECT COUNT(*) FROM Products&quot;,conn); int Count = (int)cmd.ExecuteScalar(); Console.WriteLine(&quot;商品数は&#123;0&#125;件です。&quot;,Count); &#125;&#125;②using System.Data.SqlClient;public static int AddProductCategory(string newName, string connString)&#123; Int32 newProdID = 0; string sql = &quot;INSERT INTO Production.ProductCategory (Name) VALUES (@Name);&quot; + &quot;SELECT CAST(scope_identity() AS int)&quot;; //※CAST関数は指定されたデータに変換した式の値を返す。例：SELECT CAST(&apos;2000-10-31&apos; AS DATE) using (SqlConnection conn = new SqlConnection(connString)) &#123; SqlCommand command = new SqlCommand(sql,conn); command.Parameters.Add(&quot;@Name&quot;,SqlDbType.VarChar); command.Parameters[&quot;@Name&quot;].Value = newName; try &#123; conn.Open(); newProdID = (Int32)cmd.ExecuteScalar(); &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); &#125; &#125; return (int)newProdID;&#125; 十六、ExecuteReaderの使い方12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788①using System;using System.Collections.Generic;using System.Configuration;using System.Data.SqlClient;using WebApplication1.Models;public List&lt;usermodel&gt; GetData()&#123; var list = new List&lt;usermodel&gt;(); //接続文字列の取得 var connString = ConfigurationManager.ConnectionStrings[&quot;sqlsvr&quot;].ConnectionString; using (var conn = new SqlConnection(connString)) using (var command = conn.CreateCommand()) &#123; try &#123; //データベースの接続開始 conn.Open(); //SQLの設定 command.CommandText = @&quot;SELECT ID,PASSWORD,ROLE_NAME FROM T_USER&quot;; //SQLの実行 using (var reader = command.ExecuteReader()) &#123; while(reader.Read()) &#123; list.Add(new UserModel() &#123; Id = reader[&quot;ID&quot;] as string, Password = reader[&quot;PASSWORD&quot;] as string, RoleName = reader[&quot;ROLE_NAME&quot;] as string &#125;); &#125; &#125; &#125; catch (Exception ex) &#123; Console.WriteLine(ex.Message); throw; &#125; finally &#123; //データベースの接続終了 conn.Close(); &#125; &#125; return list;&#125;②public void Test()&#123; SqlConnection conn = new SqlConnection(); SqlCommand command = new SqlCommand(); DataTable dt = new DataTable(); string id = string.Empty; string name = string.Empty; int price = 0; //データベースに接続 conn.ConnectionString = @&quot;Data Source=PC\SQLEXPRESS1;Initial Catalog=TestDatabase;User Id = sa;Password=sa;&quot;; conn.Open(); //SELECT文を設定します。 command.CommandText = &quot;SELECT * FROM T_USER&quot;; command.Connection = conn; //SQLを実行します。 SqlDataReader reader = command.ExecuteReader(); //結果を表示します。 while(reader.Read()) &#123; id = (string)reader.GetValue(0), name = (string)reader.GetValue(1), price = (long)reader.GetValue(2); Console.WriteLine(&quot;ID:&quot; + id + &quot;名称:&quot; + name + &quot;価格:&quot; + price); &#125; //接続を解除する conn.Close();&#125; 十七、sessionの使い方(sessionでページ間の値の受け渡し)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748default.aspx,csusing System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;namespace SessionVariable&#123; public partial class _default : System.Web.UI.Page &#123; protected void Page_Load(object sender,EventArgs e) &#123; &#125; protected void button1_Click(object sender,EventArgs e) &#123; Session[&quot;value&quot;] = TextBox1.Text; Response.Redirect(&quot;result.aspx&quot;); &#125; &#125;&#125;result.aspx,csusing System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.UI;using System.Web.UI.WebControls;namespace SessionVariable&#123; public partial class result : System.Web.UI.Page &#123; protected void Page_Load(object sender,EventArgs e) &#123; if(Session[&quot;value&quot;] != null) &#123; Label1.Text = (string)Session[&quot;value&quot;]; &#125; &#125; &#125;&#125; 十八、Cookieの使い方1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980①public partial class _Default : System.Web.UI.Page&#123; protected void Page_Load(object sender,EventArgs e) &#123; Label1.Text = string.Empty; if (Request.Cookies[&quot;userId&quot;] != null) &#123; Label1.Text += Server.HtmlEncode(Request.Cookies[&quot;userId&quot;].Value); &#125; if (Request.Cookies[&quot;userName&quot;] != null) &#123; HttpCookie cookie = Request.Cookie[&quot;userName&quot;]; Label1.Text += Server.HtmlEncode(cookie.Value); &#125; &#125; //Cookieの設定 protected void Button1_Click(object sender,EventArgs e) &#123; //Cookie設定方法例1 Response.Cookies[&quot;userId&quot;].Value = &quot;UID0001&quot;; Response.Cookies[&quot;userId&quot;].Expires = DateTime.Now.AddDays(10); //Cookie設定方法例2 HttpCookie cookie = new HttpCookie(&quot;userName&quot;); cookie.Value = &quot;masao&quot;; cookie.Expires = DateTime.Now.AddDays(10);//有効期設定 Response.Cookies.Add(cookie); &#125; //Cookieの削除 protected void Button2_Click(object sender,EventArgs e) &#123; //Cookie削除例1 Response.Cookies[&quot;userId&quot;].Value = &quot;UID0001&quot;; Response.Cookies[&quot;userId&quot;].Expires = DateTime.Now.AddDays(-3); //Cookie削除例2 HttpCookie cookie = new HttpCookie(&quot;userName&quot;); cookie.Value = &quot;masao&quot;; cookie.Expires = DataTime.Now.AddDays(-3); Response.Cookies.Add(cookie); &#125;&#125;②１つの Cookie に複数のキーと値を設定protected void Page_Load(object sender,EventArgs e)&#123; Label1.Text = string.Empty; if (Request.Cookies[&quot;accessUser] != null) &#123; Label1.Text += Server.HtmlEncode(Request.Cookies[&quot;accessUser&quot;][&quot;userId&quot;]); Label1.Text += Server.HtmlEncode(Request.Cookies[&quot;accessUser&quot;][&quot;userName&quot;]); Label1.Text += Server.HtmlEncode(Request.Cookies[&quot;accessUser&quot;][&quot;lastAccessTime&quot;]); &#125;&#125;// Cookie の設定protected void Button1_Click(object sender, EventArgs e)&#123; // Cookie 設定方法例１ Response.Cookies[&quot;accessUser&quot;][&quot;userId&quot;] = &quot;UID0001&quot;; // ユーザーID Response.Cookies[&quot;accessUser&quot;][&quot;userName&quot;] = &quot;&lt;まさお&gt;&quot;; // ユーザー名 Response.Cookies[&quot;accessUser&quot;][&quot;lastAccessTime&quot;] = DateTime.Now.ToString(); // 最終アクセス時間 Response.Cookies[&quot;accessUser&quot;].Expires = DateTime.Now.AddDays(10); // Cookie の有効期間（10日） //// Cookie 設定方法例２ //HttpCookie cookie = new HttpCookie(&quot;accessUser&quot;); //cookie.Values[&quot;userId&quot;] = &quot;UID0001&quot;; // ユーザーID //cookie.Values[&quot;userName&quot;] = &quot;&lt;まさお&gt;&quot;; // ユーザー名 //cookie.Values[&quot;lastAccessTime&quot;] = DateTime.Now.ToString(); // 最終アクセス時間 //cookie.Expires = DateTime.Now.AddDays(10); // Cookie の有効期間（10日） //Response.Cookies.Add(cookie);&#125; 十九、CSVデータファイルからデータの読込123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100①using System;using System.IO;static void ReadCsv&#123; try &#123; //csvファイルを開く using (var sr = new StreamReader(@&quot;test.csv&quot;)) &#123; //ストリームの末尾まで繰り返す while (!sr.EndofStream) &#123; //ファイルから一行読込む var line = sr.ReadLine(); var values = line.Split(&apos;,&apos;); foreach (var value in values) &#123; Console.Write(&quot;&#123;0&#125;&quot;,value); &#125; Console.WriteLine(); &#125; &#125; &#125; catch (System.Exception e) &#123; Console.WriteLine(e.Message); &#125;&#125;②using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;using Microsoft.VisualBasic.FileIO;namespace CSVTextFieldParser&#123; public partial class FormMain : Form &#123; public FormMain() &#123; InitializeComponent(); &#125; private void button1_Click(object sender,EventArgs e) &#123; if (openFileDialog1.ShowDialog() == DialogResult.OK) &#123; label1.Text = openFileDialog1.FileName; TextFileParser parser = new TextFieldParser(openFileDialog1.FileName,Encoding.GetEncoding(&quot;Shift_JIS&quot;)); parser.TextFieldType = FieldType.Delimited; parser.SetDelimiters(&quot;,&quot;); //&quot;,&quot;区切り //parser.SetDelimiters(&quot;\t&quot;); //タブ区切り(TSVファイルの場合) while (parser.EndOfData == false) &#123; string[] column = parser.ReadFields(); for (int i = 0;i &lt; column.Length; i++) &#123; textBox1.Text += column[i] + &quot;\r\n&quot;; &#125; textBox1.Text += &quot;===\r\n&quot;; &#125; &#125; &#125; &#125;&#125;③CSVファイルを二次元配列に格納public string[][] readingCsv(Form1 form1)&#123; List&lt;string[]&gt; readCsvList = new List&lt;string[]&gt;(); if (openFileDialog.ShowDialog() == DialogResult.OK) &#123; form1.readCsvLabel.Text = openFileDialog.FileName; using (StreamReader sr = new StreamReader(openFileDialog.FileName, Encoding.GetEncoding(&quot;utf-8&quot;))) &#123; while (!sr.EndOfStream) &#123; var line = sr.ReadLine(); readCsvList.Add(line.Split(&apos;,&apos;)); &#125; &#125; &#125; return readCsvList.ToArray();&#125;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>奋斗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本情報技術者試験の知識]]></title>
    <url>%2F%E5%9F%BA%E6%9C%AC%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93%E8%80%85%E8%A9%A6%E9%A8%93%E3%81%AE%E7%9F%A5%E8%AD%98.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;基本情報技術者試験の午前選択問題知識のまとめ。１、キーロガー(Keylogger) は、PCへのキーボードやマウス入力を逐一監視し、それを記録するソフトウェアまたはハードウェアです。悪意を持ってPCにインストール された場合には、利用者の入力情報を秘密裏に盗むことも可能で、キー入力データを解析し IDやパスワード、クレジットカードの番号などを不正に入手される恐れが あることからセキュリティ上の問題となっています。 ２、キャッシュフロー(CF)は企業会計で使われる概念で、一定期間における現金の流入出の金額を表します。「キャッシュフローを改善する」ということは組織内に現金が多く( 長く)とどまるようにするということです。 ３、オブジェクト指向プログラミングは、システムの構築や設計で、処理や対象の対象となるもの(オブジェクト)同士のやり取りの関係としてシステムをとらえる考え 方です。データと手続きをひとまとめにしてカプセル化することで実現します。 オブジェクト指向の考え方を取り入れたプログラム言語(オブジェクト指向言語)には、C++, Javaなどがありカプセル化，継承，多態性などの特徴をもっています。 ４、デュアルシステムとは、信頼化設計の1つで、同じ処理を2組のコンピュータシステムで行い、その結果を照合機でチェックしながら処理を進行していくシステム構 成です。一方の系統に障害が発生した場合でも、それを切り離して処理を中断することなく続けることができます。デュプレックスシステムでは待機系から主系へ切り 替えるのに一定の停止時間が生じますが、デュアルシステムでは切り離すだけなので中断時間はデュプレックスシステムよりも短くなります。 ５、トップダウンテストは、上位のモジュールから下位のモジュールへと順に結合しながらテストをしていく手法です。上位のモジュールから先に検証していくので、 未完成の下位モジュールの代わりに上位モジュールからの呼び出しに対して適切な値を返す役割を持つスタブが必要になります。 逆に下位モジュールから検証を開始するボトムアップテストでは、未完成の上位モジュールの代わりとなるドライバが必要となります。 ６、ADSL(Asymmetric Digital Subscriber Line)は、一般家庭に普及しているアナログ電話回線(ツイストペア線)をそのまま利用し、それまでに使用されていなかった 周波数帯域を利用することでディジタル通信を行う伝送方式です。「下り」(通信業者から利用者へ)と「上り」(利用者から通信業者へ)の通信速度が異なるため非対称 ディジタル加入者線とも呼ばれます。 ７、レビューは工程ごとに文書やプログラムなどの成果物に誤りが無いかを確認・検証する作業です。レビューの実施により潜在的なバグが取り除かれる確率が高まる ので、レビュー時間が長いほど最終的な品質も高くなると言えます。 ８、時系列分析は、時系列データを分析することで、それらの関係を明らかにし、将来の売り上げ予測などに用いる手法です。 ９、オブジェクト指向において、クラスはオブジェクトの定義情報、インスタンスはクラスの定義情報を用いて生成された具体的なデータをもつ実体です。クラスは定 義情報だけをもった入れ物に過ぎませんから、1つのクラスからから異なる値をもつ複数のインスタンスが生成できます。 １０、メッセージ認証符号(Message Authentication Code:MAC)は、通信コードの改ざん有無を検知し、完全性を保証するために通信データから生成する固定長のコー ド(メッセージダイジェスト)です。MACの目的は改ざんの検知なのでディジタル署名と似ていますが、生成には公開鍵暗号方式ではなく共通鍵暗号方式やハッシュ関数 が用いられます。 １１、ボリュームライセンスとは、1つのソフトウェア製品に複数の利用権（ライセンス）をまとめて、割引価格で提供する販売形態のことである。企業などソフトウ ェアの大量購入社向けに，マスタを提供して，インストールの許諾数をあらかじめ取り決める契約。 １２、パターンマッチング方式は、コンピュータウイルスやワームを検出するための代表的な方式で、そのウイルスが持つ特徴的なコードをパターン(シグネチャコー ド)として検査対象のファイルと比較することでウイルスの検出を試みます。検出できるウイルスはパターンファイルに定義されているものに限るので、定義されてい ないものや次々と亜種が作られるもの、未知のウイルスなどを検出することは困難です。 １３、IPv6(Internet Protocol Version 6)は、現在インターネットで主流であるIPv4の次期バージョンです。IPv4のアドレス空間は32ビットですが、インターネット の世界的な普及で枯渇することが確実になっています。 この問題への対策として、策定されたのがIPv6であり、IPv4からIPv6への主な変更点は次の通りです。 アドレス空間を32ビットから128ビットに拡大。ヘッダのサイズを可変長から固定に変更。IPアドレスの自動設定とIPsecによるIP層でのセキュリティ強化。 １４、コンピュータは、次のようなサイクルを繰り返して命令を処理していきます。 1プログラムカウンタを参照して、次に実行すべき命令が格納されている位置を知る。 2主記憶から命令レジスタに命令を読込む。(命令フェッチ) 3その次に実行する命令の主記憶上のアドレスをプログラムカウンタに格納する。 4命令レジスタの命令を命令デコーダで解読(解釈)する。(命令デコード) 5演算で必要となる値(オペランド)を主記憶やレジスタから読込む。(オペランド読出し) 6命令を実行する。 7実行結果を主記憶やレジスタに書込む。 １５、サプライチェーンマネジメント(SCM)は、生産・在庫・購買・販売・物流など、すべての情報をリアルタイムに交換することによってサプライチェーン全体の効 率を大幅に向上させる手法です。 素材，部品，製品，流通および販売までの連鎖(サプライチェーン)を最適化することで無駄な在庫や生産を減らし効率化を図ることができます。 １６、特許権は、自然の法則や仕組みを利用した価値ある発明に対して、独占的・排他的し利用できる権利で、関係機関に申請をして認められれば権利として登録され ます。 １７、SOAP(ソープ，Simple Object Access Protocol)は、ソフトウェア同士がメッセージを交換する遠隔手続き呼び出し(RPC)のためのプロトコルです。汎用なデータ 形式であるXMLに基づいて記述されており、Webサービスにとって有効な手段の一つとなっています。 １８、キャッシュメモリと主記憶が存在する場合、実際の1アクセスに要する平均時間を平均(実効)アクセス時間といい、以下の公式で計算することができます。(キャッシュメモリのアクセス時間×ヒット率)＋主記憶のアクセス時間×(1－ヒット率)キャッシュメモリと主記憶では、キャッシュメモリのほうが圧倒的に高速にアクセスできるため、平均アクセス時間は「ヒット率が高いほど短く、ヒット率が低いほど 長くなる」関係にあります。 １９、フェールセーフ(fail safe)は、システムの不具合や故障が発生したときに、障害の影響範囲を最小限にとどめ、常に安全を最優先にして制御を行う考え方です 。例えば「工業用機械で進入禁止区域をセンサーで監視し、人や物の侵入を感知したときには機械を緊急停止する」「信号機の故障が検知されたときは交差点内の全て の信号機を赤にする」というような設計がフェールセーフの実践例です。 ２０、ITサービス提供者が構築するサービスマネジメントシステム(以下、SMS)への要求事項を示したJIS Q 20000-1:2012では、SMSにおけるPDCAサイクルを次のように 規定しています。・Plan(計画)SMSを確立し、文書化し、合意する。SMSには、サービスの要求事項を満たすための方針、目的、計画及びプロセスが含まれる。・Do(実行)サービスの設計、移行、提供及び改善のためにSMSを導入し、運用する。・Check(点検)方針、目的、計画及びサービスの要求事項について、SMS及びサービスを監視、測定及びレビューし、それらの結果を報告する。・Act(処置)SMS及びサービスのパフォーマンスを継続的に改善するための処置を実施する。 ２１、ベンチマーキングは、企業経営で用いられる分析手法です。 自社の製品・サービス及びプロセスを定量的・定性的に測定し、それを業界で最も成功を収めている企業(ベスト企業)のものと比較しそのギャップを把握することを表す。 分析により明らかになったギャップを埋めるためにベスト企業のベストプラクティスを参考に業務改善を進めます。 ２２、メモリインタリーブは、物理上は1つである主記憶領域を、論理的な複数の領域(バンク)に分け、これに並列アクセスすることで見かけ上のアクセス時間の短縮 を図るメモリアクセス高速化の手法です。 ２３、プロダクトポートフォリオマネジメント(PPM)は、縦軸に市場成長率，横軸に市場占有率をとったマトリックス図を四つの象限に区分し，製品の市場における位 置付けを分析して資源配分を検討する手法です。4つの象限は、市場内の位置付けから以下のような名称で呼ばれています。・花形(star)…[成長率：高、占有率：高]占有率・成長率ともに高く、資金の流入も大きいが、成長に伴い占有率の維持には多額の資金の投入を必要とする分野。・金のなる木(cash cow)…[成長率：低、占有率：高]市場の成長がないため追加の投資が必須ではなく、市場占有率の高さから安定した資金・利益の流入が見込める分野。・問題児(problem child)…[成長率：高、占有率：低]成長率は高いが占有率は低いので、花形製品とするためには多額の投資が必要になる。投資が失敗し、そのまま 成長率が下がれば負け犬になってしまうため、慎重な対応を必要とする分野。・負け犬(dog)…[成長率：低、占有率：低]成長率・占有率ともに低く、新たな投資による利益の増加も見込めないため市場からの撤退を検討されるべき分野。 ２４、ウォームスタート方式は、ハードウェアに影響がない障害が発生したときに、システムやコンピュータに電源が入っている状態でソフトウェアリセットなどによ って再始動を行うことです。ウォームスタートの場合は、直近のチェックポイントまで戻り、更新後ログを使用してそれ以後に実行されたトランザクションをデータベ ースに反映することで回復させます。 ２５、アクセシビリティとは、「年齢や身体的制約・利用環境などにかかわらず、さまざまな製品や建物やサービスなどを支障なく利用できるかどうか、あるいはその 度合いをいいます。 ２６、コンパイル方式では、コンパイルの過程でソースコードの最適化を行ってから実行ファイルを生成します。インタプリタでは、ソースコードを1行ずつ翻訳しな がら実行するため処理の最適化は行われません。 ２７、WTO加盟国の政府関係機関での採用とのことなので、選択肢の中で唯一国際規格であるISOに基づく開発が最も適していると言えます。 ２８、線形探索法探索対象のデータ群の先頭から順に値を比較していく方法。データ群が整列されていなくても探索できるが、使用頻度が高い順に整列されていると少 ない回数で目的のデータを探索することが可能になる。平均比較回数:(N＋1)／2，最大比較回数:n2分探索法探索データが昇順または降順に整列されているときに用いる方法。データ中央値と探索対象のデータを比較し、そ の大小により探索範囲を1／2ずつ狭めていくことで線形探索と比べて効率よく探索することが可能。 平均比較回数:[log2N]，最大比較回数:[log2N]＋1 (※[a]はaを超えない最大の整数を表します) ２９、プロジェクトにおけるコミュニケーション手段は次の3種類に分類することができます。プル型コミュニケーション掲示板やe-ラーニングなどのように受信者が 自分の意思で必要になったときに情報にアクセスさせる方法。プッシュ型コミュニケーション電子メールや手紙、FAXなどのように特定の相手に向けて情報を発信する 方法。相互方向コミュニケーション会議やテレビ電話などのように複数の参加者がそれぞれの参加者同士で情報をやり取りできる方法。 ３０、CIO(Chief Information Officer，最高情報責任者)とは、情報や情報技術に関する上位の役員のことで経営戦略に沿った情報戦略やIT投資計画の策定などを役割 とします。 ３１、再配置は、プログラムが配置された主記憶上の位置に対応して、プログラム内のアドレス情報を設定することです。 ３２、Telnet(テルネット) は、IPネットワークにおいて、遠隔地（リモート）にあるサーバを端末から操作できるようにする仮想端末ソフトウェア（プログラム）、ま たはそれを可能にするプロトコルです。 ３３、RFP(Request for Proposal，提案依頼書)は、情報システムの調達を予定している企業・組織が、発注先候補のITベンダに対して具体的なシステム提案をするよ うに求めること、またはそれらのシステム要件や調達要件を取りまとめた文書をいいます。 ３４、プログラミングの標準化とは、変数や関数の命名、コメント付加やインデントに一定の規則をつけることです。規則に従ってプログラミングを行うことでプログ ラマの犯しやすい誤りを未然に防止する効果があります。 またシステムやソフトウェアの開発は個人でなくチームで行うため、当初の作成者以外の人が作業を引き継いだり、修正を行う場合があります。標準化をすることで他 人の書いたソースコードでも読みやすくなり作業時の負荷が軽減されます。 ３５、TCO(Total Cost of Ownership)は、ある設備・システムなどにかかわる、購入から廃棄までに必要な時間と支出を総計した金額を表します。 またTCOは、システム開発やハードウェア導入，ソフトウェアの導入など初期投資に必要となる「イニシャルコスト」と、運用・保守・教育・アップグレードなど維持 管理に必要となる「ランニングコスト」に分類することができます。 ３６、2相コミットは、トランザクションを、他のサイトに更新可能かどうかを確認する第1フェーズと、更新を確定する第2フェーズに分け、各サイトのトランザクシ ョンをコミットもロールバックも可能な中間状態(セキュア状態)にした後、全サイトがコミットできる場合だけトランザクションをコミットするという方法で分散デー タベース環境でのトランザクションの原子性・一貫性を保証する手法です。 ３７、SGML(Standard Generalized Markup Language)は、文書を電子的に変換するための汎用マークアップ言語で、文書の中にタグを埋め込んで、書体や文字の大きさ 、段落などを記述することができます。タグを用いたマークアップ言語であるHTMLやXMLはSGMLをベースにして開発されました。 ３８、ディジタルフォレンジクスとは、不正アクセスや情報漏えいなどのセキュリティインシデントの発生時に、原因究明や法的証拠を明らかにするために対象となる 電子的記録を収集・解析することです。 ハッシュ関数は、長い文章やデータを固定長のビット列に圧縮する一方向性の関数で、圧縮された値をハッシュ値と呼びます。この技術は、ハッシュ値にディジタル署 名を付して、本人性と文書の真正性の証明に利用したり、証拠の保全・開示に広く利用されています。 ３９、ECC(Error Check and Correct)は、誤り訂正符号としてハミング符号や垂直水平パリティを用いることで、記録内容に発生した誤りを検知・自動訂正できる誤り 制御方式です。また、この機能を搭載したメモリをECCメモリといいます。 ４０、WAF(Web Application Firewall) は、Webアプリケーションの防御に特化したファイアウォールで、パケットのヘッダ部に含まれるIPアドレスやポート番号だけで なくペイロード部(データ部分)をチェックし、攻撃の兆候の有無を検証します。これによりWebアプリケーションに対する攻撃を検知し、遮断することが可能です。 ４１、プロダクトライフサイクルは、製品を市場に投入してから販売活動によって普及、成熟しやがて落ち込んでその寿命が終わるまでの過程です。 商品の一生を、導入期、成長期、成熟期、衰退期というように推移していくと考えます。導入期商品投入に関するイニシャルコストがまだ回収されていないためキャッ シュフローはマイナスになります。成長期成長性を高めるため広告宣伝費の増大が必要になります。成熟期商品の特性を改良し、他社との差別化を図る戦略をとります 。衰退期他社からのマーケット参入が相次ぎ，競争が激しくなります。 ４２、ファシリテータ(Facilitator)は、「進行役」として会議の支援を専門的に行う人のことです。会議中に自らの意見を主張したり、意思決定をしたりすることは せず、中立的な立場から議事の進行をコーディネートします。会議を設定する、発言を促す、話を整理する、話の脱線を防ぐことなどがファシリテータの役割です。フ ァシリテータを設けることで、参加者の活性化や相互理解および合意形成を促進する効果があります。 ４３、インスペクション(Inspection)は、事前に役割を決められた参加者が責任のある第三者(モデレータ)の下で成果物を確認する、最も公式なレビュー技法です。通 常3人から6人が参加して実施され、各参加者は、モデレータ、オーナ、インスペクタ、プレゼンタ、スクライブなどの役割を持ちます。他のレビュー法と比較したとき のインスぺクションの特徴は以下の3点です。1.参加者の役割が明確になっていること2.チェックリストなど形式的な文書に基づいて実施すること3.レビュー記録を正式な形で残すこと ４４、要件定義プロセスは、システムライフサイクルにおける2番目のプロセスで、利害関係者要求の明確化と制約事項の定義に関わる作業を実施するプロセスです。 新たに構築する業務、システムの仕様、及びシステム化の範囲と機能を明確にし、それらをシステム取得者側の利害関係者間で合意することを目的としています。この 工程で定義された内容は、要件定義書に取りまとめられシステム設計工程へ引き継がれていきます。 ４５、ITポートフォリオは、ポートフォリオの考え方を情報化投資戦略に応用したものです。 IT投資をその目的やリスクの特性ごとにカテゴライズし、そのカテゴリごとに投資割合を管理することで、限りある経営資源を有効に配分することが可能になります。 経済産業省が提唱するモデルでは「戦略目標達成型」「業務効率化型」「インフラ構築型」の3つのカテゴリに分類した後、いくつかの評価項目を用いて優先順位を決 定します。 ４６、オブジェクト指向の基本概念である、抽象化、具体化、カプセル化、継承、クラス、多様性については以下の通りです。抽象化 ある実体としてのオブジェクト群から共通する性質・要素・動作を引き出して、それらの事実を包括する概念を定義すること。例えば、人間がもつ性質を定義した人間 クラスを作成すること、または人間、ゴリラ、サルから共通する要素を引き出し、霊長類クラスを作成することなどが抽象化に該当する。具体化 抽象化とは反対に、一般化されたクラスに、ある実体が持つ固有の性質・要素・動作を加えることで、その実体に特化した概念を定義すること。例えば、自動車クラス を特化させた、バス、トラック、自家用車などのクラスを定義することなどが具体化に該当する。カプセル化(情報隠ぺい) データ(属性)とそのデータに対する手続きをひとつにまとめること。カプセルのようにオブジェクトの内部を隠ぺい(ブラックボックス化)することで、使う人は内部の 情報を知らなくともオブジェクトを扱うことができる。継承(インヘリタンス)ある上位のクラスをもとに下位クラスを定義するとき、下位クラスに上位クラスの属性が 引き継がれる性質のこと。クラス いくつかの似ているオブジェクトに共通する性質を抜き出して、属性・手続きを一般化(抽象化)して新しく定義したもの。多様性(ポリモルフィズム) オブジェクトへの操作呼び出しが、呼び出し側でなく受け手側の特性で決まる特性のこと。同じメッセージを送っても受け手によって行われる操作が異なる様子を示す 。 ４７、ホスティングサービス(Hosting Service)は、サービス提供者が自らの施設内で運用している機器の全部または一部を、顧客に有料あるいは無料で貸し出すサー ビスです。機器を自分で所有する場合と異なり、設置環境の整備、機器のメンテナンス、障害対応、ソフトウェアアップデートなどの維持管理は事業者側の責任で行わ れるので、利用者側ではこれらの管理コストが掛からないという利点があります。代表的な例としてレンタルサーバが挙げられます。 ４８、CGM(Consumer Generated Media)は、主にインターネットを利用して消費者やユーザがその内容を生成する形態のメディアです。不特定多数の個人によって書き こまれる記事や作品をデータベース化してコンテンツとするWebサイトがこれに該当し、ブログやSNS、口コミサイト、Q&amp;Aコミュニティ、写真共有サイトや動画共有サ イトなどが代表的な存在です。 ４９、親和図法は、新QC七つ道具の1つで、あるテーマに基づいて集めたデータを親和性によってグループ分けすることで項目を整理する手法です。 ５０、かんばん方式は、工程間の中間在庫の最少化を目的として”かんばん”と呼ばれる生産指示票を使う生産システムで、ジャストインタイム生産方式を実現するため に重要な役割を果たす要素です。 ５１、IPv4におけるA～Dの各アドレスクラスは、以下のようにIPアドレスの先頭4ビットによって区別されています。クラスA先頭ビットが0 (先頭8ビットの10進表記が 0～127)クラスB先頭ビットが10 (先頭8ビットの10進表記が128～191)クラスC先頭ビットが110 (先頭8ビットの10進表記が192～223)クラスD先頭ビットが1110 (先頭8ビ ットの10進表記が224～239) ５２、ひずみゲージは、物体のひずみを測定するためのセンサです。薄い絶縁体上にジグザグ形状にレイアウトされた金属の抵抗体(金属箔)が取り付けられた構造をし ており、変形による電気抵抗の変化を測定することによりひずみ量に換算します。 ５３、RAID1は、同じデータを2台の補助記憶装置のそれぞれに記録することで信頼性を高める構成です。この構成はミラーリングとも呼ばれます。 ５４、ベンチマークテストは、システムの使用目的に合わせたプログラム、あるいは評価対象の業務の典型的な処理プログラムを用いて、入出力や制御プログラムを含 めたシステムの総合的な処理性能を測定する性能評価手法です。代表的なベンチマークにSPEC，TPCなどがあります。SPECプロセッサの性能を評価するベントマークテストで、整数演算の性能を評価するSPECint、浮動小数点演算能力 を評価するSPECfpがある。TPCオンライントランザクション処理システムの性能を評価するベンチマークテスト ５５、トレンドチャートは、計画の予算・工期、および実績の費用・進捗を表す2本の折れ線グラフを並べたグラフで、差異の把握や傾向(トレンド)の分析に用いられ ます。 ５６、OpenFlowとは、既存のネットワーク機器がもつ制御処理と転送処理を分離したアーキテクチャです。制御部をネットワーク管理者が自ら設計・実装することで、 ネットワーク機器ベンダの設定範囲を超えた柔軟な制御機能を実現できます。 ５７、USB3.0は、現在最も普及している周辺機器接続のためのシリアルインターフェイスのバージョン3に当たる規格です。 USB2.0から3.0への進化で最も特徴的なのが最大転送速度の大幅な向上です。2.0では”ハイスピードモード”の480Mbpsが最大でしたが、3.0では5Gbpsの”スーパースピー ド”が加わっています。さらに2013年8月に策定されたバージョン3.1では、3.0の2倍となる10Gbpsの転送を可能にする”スーパースピードプラス”が登場しています。 ５８、SMTP-AUTH(SMTP Authentication)は、メール投稿にあたってユーザ認証の仕組みがないSMTPを拡張し、ユーザ認証機能を追加した仕様です。利用するにはメール サーバとクライアントの双方が対応していなければなりませんが、メール送信する際にユーザ名とパスワードで認証を行い、認証されたユーザのみからのメール送信を 許可することで不正な送信要求を遮断することができます。 ５９、ポートスキャナ(Port Scanner)は、検査対象のコンピュータやルータの全て(または特定範囲)の通信ポートに信号を送ることで、サービスの稼働状態を外部から 調査するツールです。 このポートを調査する行為をポートスキャンといい、セキュリティ上の問題のあるサービスや、既知のセキュリティホールがそのままになっているサービスの検出を目 的として行われます。 ６０、タイムスタンプは、対象の電子データのハッシュ値と、信頼できる第三者機関である時刻認証局(TSA:Time Stamp Authority)が発行する時刻情報を含んだ電子デ ータです。検証時には、電子データのハッシュ値とタイムスタンプ内のハッシュ値の比較により、付与時点での「存在性」および、その時刻以後の「完全性」を確認で きます。またタイムスタンプにTSAのディジタル署名を付する方式もあります。 ６１、2分探索法は、”要素が昇順または降順に整列された集合”に対して、探索範囲の中央に位置する値と目的の値を比較して探索範囲を1／2に狭めることを再帰的に 繰り返して目的のデータを探索するアルゴリズムです。 ６２、サーバの処理能力を向上させる施策には「スケールアップ」と「スケールアウト」という2つのアプローチに大別されます。スケールアップサーバを構成する各 処理装置をより性能の高いものに交換したり、プロセッサの数などを増やすことでサーバ当たりの処理能力を向上させる。追加・削除・更新処理が頻繁に発生するなど 、並列実行による負荷分散が困難なシステムに適している。スケールアウト接続されるサーバの台数を増やすことでサーバシステム全体としての処理能力や可用性を向 上させる。同等の性能アップであればスケールアップよりも低コストであることが多い。 ６３、ディレクトリトラバーサル攻撃は、ユーザが入力したファイル名をパラメータとして受け取り、それをもとに処理を行うアプリケーションに対して行われる攻撃 手法です。 相対パス指定において親ディレクトリを表す(../)など、システムが想定外のファイル名を指定することで、本来秘匿にされているファイルを不正に閲覧及び取得する ことを目的としています。 ６４、ブルートフォース攻撃は、特定の文字数、および、文字種で設定される可能性のあるすべての組合せを試すことで不正ログインやパスワード解析を試みる攻撃手 法で、「総当たり攻撃」とも呼ばれます。パスワード長が短く、使用可能な文字種が少ない場合には、この手法によって破られる可能性が高くなってしまいます。 ６５、C&amp;C(コマンド&amp;コントロール)サーバは、攻撃者が、マルウェアに対して指令コマンドを送信し、マルウェアに感染した支配下のコンピュータ群の動作を制御する ために用いられる外部の指令サーバです。 ６６、メモリリーク(MemoryLeak)は、コンピュータの動作中に使用可能な主記憶容量が徐々に減少していく状態を表します。アプリケーションが「自身で獲得したメモ リの解放忘れる」などのプログラム不備などが原因で発生します。 ６７、リスクマネジメントの規格であるJIS Q 31010:2012では、リスクアセスメントを「リスクアセスメントは，リスク特定，リスク分析及びリスク評価の全般的なプ ロセスである。」と定義しています。 ６８、ディープラーニング(Deep Learning)は、人間や動物の脳神経をモデル化したアルゴリズム(ニューラルネットワーク)を多層化したものを用意し、それに「十分 な量のデータを与えることで、人間の力なしに自動的に特徴点やパターンを学習させる」ことをいいます。人工知能分野における要素技術の1つで、深層学習とも呼ば れます。 ６９、サプライチェーンマネジメント(Supply Chain Management)は、生産・在庫・購買・販売・物流などすべての情報をリアルタイムに交換することによってサプラ イチェーン全体の効率を大幅に向上させる経営手法です。導入することによって納期短縮や在庫削減といった効果が期待できます。 ７０、SOA(Service Oriented Architecture)は、従来ソフトウェアで実現されていた機能や部品を独立したサービスとして公開し、それらを組み合わせてシステムを構 築するという考え方です。サービスという単位で扱うことでシステムの統合や再利用がしやすいメリットがあります。 ７１、MRP(Materials Requirements Planning)は、日本語では資材所要量計画と呼ばれ、部品表と生産計画をもとに必要な資材の所要量を求め、これを基準に在庫，発 注，納入の管理を支援する計画方式、またはそれを実現するシステムです。 ７２、HEMS(Home Energy Management System，ヘムス)は、家庭で使用されるあらゆる電気機器をネットワークとして繋ぎ、エネルギー消費量を可視化しつつ積極的な 制御を行うことで、省エネやピークカットの効果を目指す仕組みです。政府は2030年までに全ての住宅にHEMSを設置することを目指しています。 ７３、3DCDモデルは、3次元の構造物なので視点によって見える部分が異なります。隠線消去及び隠面消去は、ある視点から見たときに物体の裏側または陰に位置し見 えなくなってしまう線および面を描画しないようにする処理です。可視／不可視を判定するアルゴリズムには、塗り重ね法、スキャンライン法、Z-バッファ法などがあ ります。 ７４、ペネトレーションテスト(侵入テスト)は、ネットワークに接続されている情報システムに対して、様々な方法を用いて実際に侵入を試みることで脆弱性の有無を 検査するテストです。 ７５、CSIRT(Computer Security Incident Response Team，シーサート)は、対象とする範囲でセキュリティ上の問題が起きていないかどうかを監視するとともに、セ キュリティインシデントの発生時に対応にあたるチームや組織の総称です。セキュリティ意識の高まりとともに企業や組織内に設置される事例が増えています。 ７６、再帰呼出しとは、関数の実行中に自分自身を呼び出すことです。 ７７、BI(Business Intelligence)は、組織のあらゆる情報を蓄積し、それらを加工・分析することで経営における意思決定に役立てようとする手法や技術の総称です 。具体的には、データウェアハウスやデータマートに蓄積された情報をデータマイニングや統計学的な解析によって分析し、経営判断上の有用な情報を取り出すなどの 活動を行います。 ７８、特定商取引は、訪問販売や通信販売などのトラブルが生じやすい取引において、購入者が受ける被害を防止するために事業者が守るべき義務を定めた法律です。 ７９、DRAM(Dynamic Random Access Memory)は、コンデンサに電荷を蓄えることにより情報を記憶し、電源供給が無くなると記憶情報も失われる揮発性メモリです。 ８０、施設の近くで落雷があると瞬間的に高い電圧(サージ)が発生します。この大きな電流が電話回線や電線を通じてシステムに侵入すると、コンピュータが壊れてし まう恐れがあります。この過電圧の被害から機器を防御するのが、SPD(Surge Protective Device，サージ防護機器)やOAタップなどに装備されているサージプロテクト 機能です。 ８１、ソフトウェア制御におけるポーリング制御は、ループにより各部の情報を一定時間ごとに順番に収集し、その情報をもとにソフトウェアの状態を判断して処理を 行う制御方式です。システム上でいつ発生するか分からないイベントを監視する目的で設定されます ８２、システムやハードウェアの故障頻度と経過年数の関係は、以下のように3つの期間に分けられます。・初期故障期間 設計や製造の不備や使用環境との相性によって故障率が高くなる期間・偶発故障期間 初期の不具合が落ち着いて安定した稼働が長く続き、偶発的な故障だけが発生する期間・摩耗故障期間 材料や部品の劣化による故障回数が多くなる期間 ８３、共通フレームは、日本のソフトウェア産業界においての”共通の枠組み”、”共通の物差し”となることを目的として作成された規格です。取得者と供給者双方また は、システム開発に関わる全ての人が、ソフトウェアを中心としたシステムの企画, 要件定義，開発，運用，保守の作業内容を共通に参照できるよう詳細に表現したり 、ソフトウェア取引を明確化するための基準が記述されています。 SLCP-JCF は、Software Life Cycle Process-Japan Common Frame の略で、ISO/IEC 12207によって規格化されたSLCPモデルに適合しつつ、日本の環境における独自の事 項を加えた規格という意味を持っています。 ８４、ICタグ(RFID)の特徴は汚れに強く，記録された情報を梱(こん)包の外から読むことができる。 ８５、パスを指定する方法には絶対パスと相対パスの2種類があります。・絶対パス 階層の最上位であるルートディレクトリを基点として，目的のファイルやディレクトリまでの全ての経路をディレクトリ構造に従って示す方法。・相対パス 現在作業を行っているカレントディレクトリを基点として、目的のファイルやディレクトリまでの全ての経路をディレクトリ構造に従って示す方法。 ８６、2要素認証とは、ICカードとパスワード、指紋とパスワードなどのように、利用者が知っている・持っている・有している情報のうち2種類の要素を使用して認証 を行う方式です。 ８７、ディジタル署名は、公開鍵暗号の技術を応用してディジタル文書の正当性を保証する技術で、ディジタル署名が付された文書は受け取った人が「発信元が正当で あるか」と「改ざんの有無」の2点を確認できるようになっています。 ８８、”システム管理基準”によれば、組織全体の情報システムのあるべき姿を明確にする計画は全体最適計画です。開発計画は、全体最適化計画が策定された後、目的、対象業務、費用、スケジュール、開発体制、投資効果等を明確にするなどシステム化の構想・立案を行うプロセス です。事業継続計画は、予期せぬ災害が発生した場合に、最低限の事業を継続し、または早期に復旧・再開できるようにする企業が定めた行動計画のことです。 ８９、デルファイ法は、技術開発戦略の立案に必要となる将来の技術動向の予測などに用いられる技法であり、複数の専門家からの意見収集、得られた意見の統計的集 約、集約された意見のフィードバックを繰り返して最終的な意見として収束させていくものです。 ９０、SOA(Service-Oriented Architecture)は、業務上の一処理に相当するソフトウェアで実現されている機能や部品を独立したサービスとし、それらを組み合わせ連 携させることで全体のシステムを構築するという手法、またはそのことを指す言葉です。 ９１、ホットスタンバイ方式は、主系と待機系の2系統で構成されるデュプレックスシステムの運用方法のひとつです。待機系の待ち状態によってホットスタンバイ、 ウォームスタンバイ及びコールドスタンバイに分類することができます。・ホットスタンバイ待機系にも主系と同じシステムを起動しておき、障害が発生した時に即座に待機系に切り替えることができるようにした方式。・ウォームスタンバイ待機系の電源は入れておくが、業務システムは起動させないで待機させておく方式。データベースだけは主系の更新内容を反映させておき、障害 発生時は主系から業務を引き継ぎます。・コールドスタンバイ通常、待機系では、他の処理を行い主系システムに障害が発生したら、その処理を中断してから業務システムを起動し引き継ぐ方式。 ９２、スプーリングは、プリンタなどの低速な入出力装置に対するデータの転送を磁気ディスク装置などを介して実行する機能のことです。入出力装置とCPUでは動作 速度の差が大きく、CPUが処理の途中で入出力命令をだすと、入出力動作が終了するまでの間はCPUの待ち時間が増加し、スループットが低下してしまいます。 スプーリングでは、入出力装置とやり取りするデータを一度外部記憶装置などへ転送し、外部記憶装置と入出力装置の間でデータをやり取り方法をとります。これによ ってCPUは低速な入出力装置の動作完了を待つことなく、次の処理に移ることができるためスループットを大幅に向上させることができます。 ９３、XBRL(eXtensible Business Reporting Language)は、各種財務報告用の情報を電子化して作成・流通・利用できるように標準化されたXMLベースの言語です。 ９４、デッドロックとは、共有資源を使用する2つ以上のプロセスが、互いに相手プロセスが必要とする資源を排他的に使用していて、互いのプロセスが相手が使用し ている資源の解放を待っている状態です。 デッドロックが発生するとプロセスは永遠に待ち状態になってしまうためプロセスの続行ができなくなってしまいます。 ９５、コンパイラは、高水準語で記述されたソースコードを機械語などに一括して翻訳するソフトウェアです。 コンパイラにおける最適化とは、そのプログラムが動作するコンピュータの設計・仕様に合わせて実行速度が速くなるような機械語に変換することをいい「不要な変数 の省略」「関数のインライン展開」「レジスタ割当て」などの手法を用いることで、与えられたソースコードを最適化された機械語に変換を行います。 ９６、ITサービスマネジメントのキャパシティ管理プロセスにおける，オンラインシステムの容量・能力の利用の監視についての注意事項のうち，適切なものは応答時間やCPU使用率などの複数の測定項目を定常的に監視する。 ９７、DNSキャッシュポイズニングは、DNSサーバからの名前解決要求があった場合に正常な応答に加えて偽の名前解決情報を付加して送信することで、そのサーバのキ ャッシュに偽の情報を登録させるという攻撃手法です。 ９８、インデックス修飾は、命令のアドレス部で指定されたメモリアドレスにインデックスレジスタの値を加算したものを実効アドレスとする方式です。 ９９、ウォークスルーは、開発者が主体となりエラーの早期発見を目的として設計書やプログラムに誤りがないかを確認するレビュー手法です。 開発メンバで実施されることが多く、管理者は原則的に参加させないという特徴があります。 １００、ゲートキーパは、IP電話サービスにおいてIPアドレスと電話番号などの相互変換などの機能をもつ機器です。 １０１、セル生産方式は、製造業における生産方式の一種で、1人、または少数の作業者チームで製品の組み立て工程を完成（または検査）まで行います。ライン生産 方式などの従来の生産方式と比較して、作業者一人が受け持つ範囲が広く多品種を生産するときフレキシブルな切り替え可能なのが特徴です。 １０２、企業内ネットワークやサーバに侵入するために攻撃者が組み込むものはバックドアです。バックドアとは、直訳すれば「裏口」若しくは「勝手口」を指し、防 犯・犯罪学上等では「正規の手続きを踏まずに内部に入る事が可能な侵入口」の事です。本来はIDやパスワードを使って通信を制限したり、使用権を確認するコンピュ ータの機能を無許可で利用するために、コンピュータ内に（他人に知られる事無く）設けられた通信接続の機能を指します。 １０３、企業経営において，ステークホルダを重視する目的は顧客，株主，従業員などの利害関係者の満足度を向上させ，企業の継続した発展を図る。 １０４、コストプラス法は、製品のコストに一定の利幅を加えて製品価格とするコスト志向型の価格設定法です。 価格の算出を計算式で表すと、製品価格＝直接費＋間接費＋利益となります。 １０５、ソフトウェア結合テストにおいて、未完成のモジュールの代わりに接合されるテスト用モジュールにスタブとドライバがあります。・スタブトップ ダウンテストにおいて未完成の下位モジュールの代わりに結合されるテスト用モジュール。上位モジュールからの呼び出しに対して適切な値を返す役割をもつ。 ・ドライバ ボトムアップテストにおいて、未完成の上位モジュールの代わりとなるテスト用モジュール。上位モジュールの代わりに下位モジュール内の命令を呼び出す役割をもつ 。 １０６、一貫性(consistency)，原子性(atomicity)，耐久性(durability)，独立性(isolation)の4つはデータベースのトランザクション処理を行う上で必要不可欠とさ れる性質で、それぞれの頭文字を並べてACID特性と呼ばれています。 この性質のうち「トランザクション内の処理がすべて実行されるか、または全く実行されないことを保証する性質」は原子性(atomicity)になります。一貫性は、トラ ンザクションによりデータの矛盾が生じないこと。常にデータベースの整合性が保たれていることを保証する性質です。耐久性は、一旦正常終了したトランザクション の結果は、以後システムに障害が発生しても失われないことを保証する性質です。永続性と呼ばれる場合もあります。独立性は、複数のトランザクションを同時に実行 した場合と、順番に実行した場合の結果が等しくなることを保証する性質です。隔離性と呼ばれる場合もあります。 １０７、DFD(Data Flow Diagram)は、データの流れに着目して、その対象となる業務のデータの流れと処理の関係をわかりやすく図式化する構造化分析の手法です。「 ○」処理・プロセス，「□」データの吸収先，「→」データの流れ，「〓」データストアの4つの記号を用いて対象業務のモデル化を行います。 １０８、インスペクション(Inspection)は、事前に役割を決められた参加者が責任のある第三者(モデレータ)の下で成果物を確認する、最も公式なレビュー技法です。インスペクションは、通常3人から6人が参加して実施されます。各参加者に割り振られる役割は次の5つです。 ・モデレータ(Moderator)議長・司会としてインスペクション全体を運営する ・オーナー(Owner)レビュー対象となる成果物の作成者で、発見された問題に応じて成果物の修正を行う ・インスペクタ(Inspector)評価者としてレビュー対象となる成果物の問題発見を行う ・プレゼンタ(Presenter)ミーティングにて参加者に資料の説明を行う ・スクライブ(Scribe)書記としてレビューで発見された問題などを記録する １０９、それぞれのバックアップ方式は次のような特徴があります。フルバックアップ方式毎回ディスク全体のバックアップを行う方式。復旧時間は短くなるが、バッ クアップに要する時間は長い。差分バックアップ方式定期的にフルバックアップを行い、フルバックアップの間の期間は、フルバックアップ以降に変更のあったファイ ル(差分)だけを記録していく方式。バックアップ時間は短くて済むが、復旧は”フルバックアップの適用→差分バックアップを適用”という流れになるのでフルバックア ップ方式と比較して時間がかかる。]]></content>
      <categories>
        <category>情報処理試験</category>
      </categories>
      <tags>
        <tag>奋斗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春節]]></title>
    <url>%2F%E6%98%A5%E7%AF%80.html</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;私の故郷は中国山東省済寧市です。済寧市は一番有名なのは、中国儒家の始祖――春秋戦国時代の孔子と孟子の出身地です。&nbsp;&nbsp;&nbsp;長い歴史の中に豊富な伝統文化が継承され、発展してきました。この中には、春節（旧暦の新年）という中国人にとって一番重要な節日である典型的な伝統文化があります。時間的には、春節は毎年異なるが、大体毎年の新暦１月の後半から2月の前半にかけての間にあることが多いです。春節期間は、企業や商店などは３日から１週間くらい休みになり、学生たちは１か月の冬休みがあります。同じ春節ですが、中国各地でのお祝い方は多少違いがあります。 &nbsp;&nbsp;&nbsp;私の故郷では、「臘月（旧暦１２月）に入れば、新年になる。」という俗話があります。１２月（旧暦）に入れば、冬休みに入った子供たちは爆竹を鳴らしたりしています。爆竹の音を聞くと、いよいよ新年が来ることを感じられ、人々は春節を楽しみにしています。でも、実家の犬――豆豆（doudou）は春節が嫌いだと思います。なぜなら、爆竹の爆発音に苦手で、爆竹の音がを聞こえると、いつも怖くて私のベッドの下に潜んでいます。春節でたくさんのおいしいものを食べる私は太りますが、豆豆は食欲不振で痩せています。また、１２月（旧暦）に入ると、一連の伝統行事が続いて来ます。例えば、臘八節(旧暦１２月８日)に、一年の豊作を祈るため、「臘八粥」(また、八宝粥といいます。)という8種類の穀物で作ったお粥を食べる習慣があります。１２月（旧暦）中頃から地方に出稼ぎに出ている人は、故郷に帰り、「春運」（何億の人が故郷に帰り、この時期の列車はすごく混雑しています。）が始まります。みんなは家族と一緒に過ごす団樂を楽しみにしているから、混雑してつらい道中でも気にせず帰省します。多くの人にとって、一年で家族や友達とを会える時期はたぶん春節だけだと思います。「お金があるかどうかに関わらず、故郷に帰り、春節を祝う」という歌詞は人々の「故郷に帰りたい」という心底の声をはっきり表しています。 &nbsp;&nbsp;&nbsp;１２月３０日（或いは３１日、旧暦一年の最後の日）朝から餃子などの「年夜飯」を準備します。「年夜飯」の食材を守ることは私の一つの仕事です。毎年の大晦日に、魚やお肉を盗む「不良」猫が猖獗し、盗む機会を狙っているのを防ぐために、見まわりの仕事が大切です。正午１２時から、大門と部屋ドアの両側に「春聯」を貼り始めます。夜（旧暦大晦日）になると、家族全員で「年夜飯」という日本のおせち料理のようなご馳走を食べます。夜８時から、中央テレビで「春節聯歓晩会」という四時間の娯楽番組があります。「年夜飯」を食べながら、番組を見るのが私にとって一番幸せなことです。「年夜飯」のメニューは、一般的に、余暇やお金が余ることを意味する余〔Yu2〕と同音の「魚」の料理、何事も年々上昇するようにという意味の「年年高昇」の年高〔Nian2 Gao1〕」と同音の「餅」の料理など縁起のよい名前の料理が好まれます。夜中の12時ちょうどになると、家々で一斉に爆竹を鳴らして新年を祝います。この時、豆豆にとって一番つらい時期でしょう。 &nbsp;&nbsp;&nbsp;故郷では、「守歳」という習慣もあります。つまり、夜明かしして新年を迎えることです。毎年「守歳」をしようとする私は、いつも途中で諦めました。多分豆豆と「不良」猫が毎年「守歳」を続けています。新年１日（旧暦１月１日）の朝からみんなは親戚と友達の家に行ってお互いに新年の挨拶をします。小さい時、正月１日に、私はいつも大きなポケットが付いている服を着きます。なぜなら、親戚と友達の家に行く時、飴とお菓子をもらえます。来るだけ多くのお飴を貰えるために、「勝負服」が必要です。賢いでしょう？しかし、私のポケットより大きなポケットを付いている服を着る子供は少なくありません。子供にとって、春節のいいことはもう一つがあります。それは、大人からお年玉（中国では「圧歳銭」といいます）も貰えることです。私の記憶では、１８歳まで、毎年の春節に大人から「圧歳銭」を貰えていました。この「圧歳銭」を使って、おいしいもの、文房具、本などを買いました。しかし、いい思い出の中に、不愉快なこともがあります。１２歳の春節（馬の年）、祖父母から貰った「圧歳銭」がなくなりました。豆豆をベッドの下から引っ張り出して抱っこしながら、泣いていました。その年の春節は、私の気持ちは豆豆と一緒だと思います。 &nbsp;&nbsp;&nbsp;中国の俗話には、「正月１５日を超えないと、新年である」があります。社会経済の発展に伴い、仕事と生活のペースが速くなっています。正月３日から人々がまた故郷を離れ、都市に戻る旅に出ました。爆竹の音も少なくなり、故郷の田舎も昔の静かな場所に戻りました。豆豆も元気になるだろう。長い間に故郷を離れた私は、故郷の春節の思いをいつまでも忘れることができません。逆に、時間が立つと、故郷の春節に関する思い出はより印象深く残っています。しかし、故郷は変わっています。ある人、ある物の姿が永遠に見えなくなりました。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于时间]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4.html</url>
    <content type="text"><![CDATA[时间，一个用手触摸不到虚无缥缈的东西，一个无法用任何词语形容的存在。虽然看不见摸不着，却让人无时无刻不感受着它的存在。时间就像一个永续的沙漏，不会因为任何因素而停止流逝。转眼间快到三十而立之年了。三十年的光阴，看似很长，却又像眨眼一样，转瞬即逝。生命面前，人人平等，只有一次。但芸芸众生却找不出完全一样的生命历程，轰轰烈烈的一辈子，平平淡淡的一辈子，碌碌无为的一辈子，遗臭万年的一辈子。小时候我曾梦想当个大人物，拥有一个轰轰烈烈的一辈子，可长大了，却发现自己只不过是平平淡淡的一辈子里一个普普通通的人。什么原因让平等的生命拥有了不同的历程，答案只能是时间。在每天24小时中，不同的选择，不同的利用，日复一日的时间堆积，便造就了不同的人生。虽然里面包含了各种比如天赋，运气，家庭背景等诸多不确定的因素，但唯一不变的却只有时间。所以，好好利用时间才是一切的关键。 我的2019年伊始，便和时间在赛跑，真真切切的体味到想抓住时间却又抓不到的挫败感。让我明白时间的宝贵。下面便是我追赶时间的辛苦经历。 公司给顾客开发的新的数据管理系统要上线，客户现场业务繁忙，系统更替时的新旧系统的并行运用由于人手不足而无法实施，取而代之的方案是——直接使用新系统。这是很冒险的做法，所以顾客现场状况不断。我主要负责将新系统的数据存入旧系统，以便以后进行新旧系统的数据对比来检验新系统的正确性和可靠性。这是一个十分繁杂的工作，原来七八个人进行的工作量一下子落在了我自己的身上。于是开始了进入公司以来最严重的加班，早上九点一直到晚上十点，一天十几个小时的重复的数据输入，让我头脑发涨，身心疲惫。最要命的是，这样的工作不知道持续到什么时候。十点下班，坐一班公交，换乘两次地铁，到家已经十一点多了，然后吃饭，洗刷，睡觉，养精蓄锐准备明天的战斗。真的像是被时间这个债主疯狂讨债，而无处藏身。在这一整天的24小时里，能属于自己支配的时间真的很少。如何在有限的时间里挤出属于自己的时间，真的要好好的计划。首先工作时间是一定的，最近一段时间内是无法改变的。睡眠时间关系到健康，也无法缩短。剩下的能有效利用的是电车里的时间和回家之后睡觉之前的时间。电车里我就看书和写点东西。但下班后坐电车时，真的挺累的，不想干任何事。想睡一会，但因换乘电车，一睡就可能坐过了，所以不敢睡。虽然知道这样的生活可能就这一段时间，但是像我这样每天疲于奔命的人不在少数，不是人们愿意如此，而是现实就那么残酷，为了生活，不得如此。尤其是人到中年，上有老下有小，不努力的话，整个家庭都会受牵连。记得看过一个在电车上，边吃面包边哭的日本上班族的图片。隔着手机屏幕都能感受到他的辛酸。每个成年人都活的不易。不过，与人类相比野生大自然的动物们生存的更加艰难。角马羚羊大军在鳄鱼血盆大口下度过宽宽的尼罗河，不过就会被饿死，过有可能被鳄鱼吃掉，而且这样的残酷抉择一年必须经历一次。一想到这样的抉择，我突然觉得人类是那么的幸福，没有那么多生与死的抉择。刚生下龇狗宝宝的龇狗妈妈为了填饱肚子，铤而走险穿越狮子领地去捕食猎物，最后被狮子发现，当场咬死，她的三只宝宝也被活活饿死。看的挺心酸的。大自然很残酷，但这就是现实，弱肉强食，地球上一个真理，无法被改变。中国近代的落后挨打到今天的富强独立也是诠释了这一真理。我们只有改变自己，变成强者，才能在这个世界上立足下去。不努力时想想非洲大草原的那些动物，我们还有什么不能面对的困难呢。 这一段时间的加班生活，虽然很苦，但给了我人生一个很好的经历，让我意识到时间的宝贵，人生苦短，且行且珍惜。希望多年后听《时间都去哪了》时，自己能自己一个满意的回答。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>奋斗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Hexo博客从HTTP到HTTPS加密]]></title>
    <url>%2F%E5%AE%9E%E7%8E%B0Hexo%E5%8D%9A%E5%AE%A2%E4%BB%8EHTTP%E5%88%B0HTTPS%E5%8A%A0%E5%AF%86.html</url>
    <content type="text"><![CDATA[本篇文章介绍如何将http的Hexo博客升级为加密的https网站。想必玩hexo博客的小伙伴们，都想把自己http网站升级成拥有加密传输的https网站。好处大致有三个，一是为了增加数据传输安全，二是谷歌百度等搜索都优先收录https网站，所以能一定程度上提高SEO排名，最后我认为有把小绿锁，能增加心里成就感。废话不多说，直接进入正题。如何将http的Hexo博客升级为加密的https网站？ 通过CloudFlare实现Hexo博客的HTTPS加密 cloudflare 是一家国外的CDN加速服务商，向客户提供网站安全管理、性能优化及相关的技术支持为主要业务。通过基于反向代理的内容分发网络(CDN, Content Delivery Network)、任播(Anycast)技术、基于nginx+lua架构的Web应用防火墙(WAF, Web Application Firewall)及分布式域名解析服务(Distributed Domain Name Server)等技术，Cloudflare可以帮助受保护站点抵御包括分布式拒绝服务攻击(DDoS, Distributed Denial of Service)在内的大多数网络攻击，确保该网站长期在线，同时提升网站的性能、访问速度以改善访客体验。首先，在CloudFlare的官网注册一个CloudFlare账号并把添加自己的域名，点击下图中的DNS项目。 然后，点击下图中红圈内的「Add Record」按钮，添加如图中的两条记录，Type都选「CNAME」,Name一个填自己的域名，另外一个填WWW，Value都填github上托管的GitHub Pages地址，即your-github-username.github.com这样的形式。]]></content>
      <categories>
        <category>hexo博客技术</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>CloudFlare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018总结和2019目标]]></title>
    <url>%2F2018%E6%80%BB%E7%BB%93%E5%92%8C2019%E7%9B%AE%E6%A0%87.html</url>
    <content type="text"><![CDATA[随着元旦脚步的临近，2018年就要接近尾声，在今年最后一个月里，我不停地在思考一个问题，在2018年里我究竟收获到了什么，失去了什么，我用时间换了什么。时间是残酷的，它带走了人部分生命，带给了人一丝的苍老。如果不在流逝的时间里，给自己留下一点有意义的东西的话，好像是在浪费自己的生命。就像《士兵突击》里许三多说的，就是没有好好的活，抛弃了自己。为此我想用这篇文章为我的2018年做一个总结，一是来回顾自己2018年的点点滴滴，二来是为了给自己以后的人生敲响一个警钟，要活的更加认真，更加珍惜每一天的时间。 2017的年末，我给自己制定了2018年的10个大的计划，现在回头看一下，才发现自己只完成了其中的6个。剩下没完成的4个计划中，最重要的一个–养成自律的习惯，直到现在我还是没有做到。一周三次的跑步没有坚持，一周一篇的博客没有坚持，每天的英语没有坚持等等。每次信誓旦旦的开始坚持做一件事，没过多久又心安理得的停顿，最后到无奈的不了了之。似乎我总是再重复这个没有意义的过程，但又缺乏足够的毅力去改变。在《刻意练习》一书中有一个被公认的事实，那就是不管是哪个领域，如果想成为专家的话，都必须要付出大量的持续的努力。为什么我的英语不好，为什么我的IT技术不好，原因很简单就是没有持续的努力下去。而对于一个走出校园的社会人来说，持续的努力，只能靠自律来实现。所以，在新的2019年里我最重要的目标就是养成自律的习惯。 先谈一下在2018年里的收获，首先是考下了两个日本的国家资格证书「セキュリティマネジメント試験」和「基本情報技術者試験」,让我有资格去获得日本高级人才签证。进公司的不到三年的时间里，已经拿了5个IT方面的资格证书。 但总感觉还远远不够，文科出身的我，本来就和计算机专业出身的人差了太多太多，所以我没有理由不更加努力。 其次利用坐电车的和午休的时间，我读了大约25本书，包括中文，日文和英文书籍。本来计划是一周至少读一本的，但由于各种备考花了很多工作之余的时间，再加上经常懒惰，所以平均两周才读完一本，在新的一年里希望把读书的好习惯延续下去，真正做到至少一周一本书外加一篇博客。 第三个收获就是让妻子也养成了读书的好习惯，今年下半年，妻子就读完了我都望而却步的超级厚书《飘》，接着又马不停蹄的读完了《平凡的世界》，《穆斯林的葬礼》，《活着》，《鲁滨逊漂流记》，《围城》，《边城》，《茶花女》,《呼啸山庄》等等。现在我觉的最快乐的时光就是和妻子一起读书。希望我们俩在2019年里读更多好书，收获更多感悟。 第四个收获就是即将拿到日本的驾照。从今年十月中旬开始，利用周末的时间，我开始了考取驾照的征程，自己好像回到校园里的学生一样，一到周末就背上教科书去驾校上课，教室里有各种国籍的人，都是为了一个目的而来，那就是早日拿到期待已久的驾照（在日本叫免许）。在教室上完交通知识课之后，还要上车学习实际的驾驶技术。记得我第一次手握方向盘，发动汽车行驶的那一刻，我的心率比平时快了好多，驾驶课结束后，才发现自己的后背已经湿透了。我想驾照不光是一种技能，更多的是一种责任，因为当手握方向盘发动汽车的那一刻，你不仅掌握着自己的命运，还有家人的命运，以及其他车上人的命运。所以，开车上路要时刻谨记安全驾驶，遵守交通规则。 第五个收获是我保持着健康。在2018年里，我没吃过药没打过针，体检也显示一切正常。我非常喜欢一句话:健康不是一切，但没有健康就没有一切。这是很真实的一句话。人这一生有太多太多重要的事，但健康却是一切的根本。没有健康，你不能享受家人的陪伴，没有健康，你不能高效的工作，没有健康，你无法实现自身的理想。为了保持健康的身体，我每天都坚持多走路，能走路去的地方就不骑自行车，不坐电车。现在自己平均每天大约走7000步，和自己定的8000步还有差距。2019年，我会朝着定下的目标继续努力下去，保持好自己的健康。 第六个收获是，我花了一个月的工作之余的时间，搭建了自己的独立博客，虽然在搭建的过程中遇到了各种各样的困难，但还是坚持了下来。尽管还有恨多需要完善的地方，我会一点一点的去完善，然后每周至少写一篇技术或读书或生活感悟的文章，以此来记录自己和家人的成长轨迹。我也会抽出时间把搭建独立博客的方法和技术总结下来，如果有兴趣搭建自己独立博客的朋友，可以做个参考，少走一些弯路。我建博客最重要的目的，是为了让自己去养成自律的习惯，去记录自己收获和成长。 第七个收获是我又学会了一门编程语言C#，进入公司我最先学会的是VB，用VB开发了三个财务数据管理和分析工具，从今年四月份开始，我在公司开始了用C#开发网页程序。与VB相比，C#网页开发开发要难的多，找bug也不像窗体程序那么容易，不过，正是因为难，才有去挑战的动力。经过几个月的努力，自己从C#的小白，变成了独立负责部分核心页面的设计与开发，不过感觉还远远不够，不会的东西太多了。在以后的日子里，我会慢慢把C#学习中的重要的知识点会写在博客里，一是方便自己复习，二是为感兴趣的朋友做个参考。IT技术要学习的地方太多了，只能一步一个脚印的走下去，慢慢的朝自己的目标迈进。 以上就是我在2018年里的大概收获，虽然留下了很多的遗憾，但总的来说，我还是比较满意我的2018年。 在新的2019年里，我想写下新的十个大的目标。以此来激励自己继续的努力。 1.读完五十本书，并写下每本书的感悟和总结。 2.考取三个资格证书。（ORACLE MASTER Bronze、ORACLE MASTER Silver、日语能力考试N 1考试160分） 3.学会一门新的语言（PHP） 4.坚持每天走8000步 5.英语TOEIC 750分 6.旅行三次（北海道，京都，重庆预定） 7.结交三个新朋友。（不分国籍，志同道合） 8.培养儿子的读书习惯。 9.继续完善个人网站和开通个人微信公众号。 10.养成自律的好习惯。 以上，就是对2019年的期待，希望自己珍惜每一分每一秒，实现自己立下的目标。也希望身边的每个朋友在新的一年也有更多的收获。 最后，以一句自己喜欢的格言，结束这篇文章— 只要尚存一丝气息，就要战斗下去。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>奋斗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插入视频]]></title>
    <url>%2FHexo%E6%8F%92%E5%85%A5%E8%A7%86%E9%A2%91.html</url>
    <content type="text"><![CDATA[本篇文章介绍在Hexo的页面内插入视频。 YouTube视频插入方法首先需要打开YouTobi官网(国内的小伙伴需要翻墙)，搜索自己感兴趣的视频。在视屏右下方，点击共有按钮，日本YouTobi显示的是共有，纯英文网站应该显示的是share。 在打开的页面上，点击第一个按钮(有这个&lt;&gt;符号的按钮)，打开链接生成页面。 把红圈内的代码复制到你的md文件中，保存之后，$ hexo g -d 生成，就可以看到插入的视频了。 这篇文章以后还要讲解Hexo博客如果添加其他网站的视频，比如优酷，哔哩哔哩，腾讯视频等等，敬请期待。如果有什么问题和建议，可以留言给我。希望对您有帮助。]]></content>
      <categories>
        <category>hexo博客技术</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加菜单]]></title>
    <url>%2FHexo%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95.html</url>
    <content type="text"><![CDATA[本篇文章介绍在Hexo的Next主题下新添加一个”学习”的菜单分类。新建一个页面，命名为study1$ hexo new page &quot;study&quot;此时会在\source文件夹中生成一个study的新文件夹编辑study文件下的md页面 将类型设置为study,主题将自动生成study这个分类。 1234title: 学习date: 2017-12-14 13:05:38type: &quot;study&quot;--- 如果有启用多说或者Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段comments并将值设置为false，如： 12345title: 学习date: 2017-12-14 13:05:38type: &quot;study&quot;comments: false--- 在菜单中添加图标和链接 编辑主题的_config.yml，在其中的menu中添加如下： 12menu: study: /study/ || heartbeat 新添加的菜单需要翻译对应的中文打开theme&gt;next&gt;languages&gt;zh-Hans.yml，在menu下添加 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 study: 学习 read: 读书 sitemap: 站点地图]]></content>
      <categories>
        <category>hexo博客技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>javascript</tag>
        <tag>CSS</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的常用写法]]></title>
    <url>%2FMarkdown%E7%9A%84%E5%86%99%E6%B3%95.html</url>
    <content type="text"><![CDATA[hexo博客的文章都是用Markdown格式编写的，所以要想熟练的编写hexo博客的话，一些常用的格式还是需要了解一下的，本篇介绍几个常用的Markdown写法，有兴趣的小伙伴们可以学习一下。1.列表 123456例: - The Beatles - Atom - git※注意:「-」和文字之间有半角空格。 2.标题 123456例:# 标题1## 标题2### 标题3※注意:「#」和文字之间有半角空格。 3.强调 12例:**Hello World** 4.引用 1234例:&gt; Beautiful is better than ugly.※注意:「&gt;」和文字之间有半角空格。 5.链接 12例:[我的博客](http://www.zhouhengheng.com) 6.取消线 12例:~~取消~~ 7.水平线 1234567格式: 从「&gt;」，「_」，「*」中任意并列三个以上例:---___*** 8.插入图片 12345格式: ![代替文字](图片URL “标题”)」）例:![名片工厂图片](https://meishi.artisj.com/summary/image/logo.gif &quot;名片工厂&quot;) 9.段落和改行 123456789段落空一整行。改行空两个半角空格以上。例:你学会使用Markdown格式了吗？只会一点，还在学习中。 10.段首空格/段首缩进1234567格式:&amp;nbsp;//半角空格&amp;emsp;//全角空格例:&amp;emsp;我叫张三。&amp;nbsp;我喜欢学习和分享。11.代码引用 ①指定开发语言时 例: ```python def hello_world(): print(‘Hello world!’) hello_world() ``` ②未指定开发语言时 例: ``` print(‘Hello world!) ```]]></content>
      <categories>
        <category>hexo博客技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[呕心呖血搭建Hexo博客]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2%E5%91%95%E5%BF%83%E5%91%96%E8%A1%80%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[自己的博客正式开始搭建，希望在今后的日子里更加努力，多读书，多学习，多分享。这个周末几乎一直在电脑前，不停的查着各种Hexo博客搭建的教程，吃力的搭建着属于自己的个人博客。虽然自己的脊椎和眼睛的疼痛不断提醒着自己该适当休息一下了，可是搭建博客的乐趣使我沉浸其中，无法自拔。终于在谷歌上输入自己域名后，自己的Hexo博客呈现的那一刻，才感觉自己的付出没有白费。就像刚开始进入IT行业一样，文科出身的我一点编程的基础没有。在密密麻麻的代码面前，我像看天书一样，一个一个的代码完全琢磨不透是什么意思。不过自己还是每天坚持下来了。真的很感谢那时的自己。不管遇到什么样的困难，只要朝准正确的方向，坚持不懈的努力，肯定会收获自己想要的结果的。 从现在开始，自己会慢慢修缮自己的博客，并且在博客上记录自己学习和成长路上的点点滴滴。加油。]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>奋斗</tag>
      </tags>
  </entry>
</search>
